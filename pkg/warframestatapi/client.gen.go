// Package warframestatapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package warframestatapi

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapitypes "github.com/oapi-codegen/runtime/types"
)

// Defines values for AlertMissionFaction.
const (
	AlertMissionFactionCorpus    AlertMissionFaction = "Corpus"
	AlertMissionFactionCorrupted AlertMissionFaction = "Corrupted"
	AlertMissionFactionGrineer   AlertMissionFaction = "Grineer"
	AlertMissionFactionInfested  AlertMissionFaction = "Infested"
	AlertMissionFactionNarmer    AlertMissionFaction = "Narmer"
	AlertMissionFactionOrokin    AlertMissionFaction = "Orokin"
	AlertMissionFactionTenno     AlertMissionFaction = "Tenno"
)

// Defines values for AlertMissionFactionKey.
const (
	AlertMissionFactionKeyCorpus    AlertMissionFactionKey = "Corpus"
	AlertMissionFactionKeyCorrupted AlertMissionFactionKey = "Corrupted"
	AlertMissionFactionKeyGrineer   AlertMissionFactionKey = "Grineer"
	AlertMissionFactionKeyInfested  AlertMissionFactionKey = "Infested"
	AlertMissionFactionKeyNarmer    AlertMissionFactionKey = "Narmer"
	AlertMissionFactionKeyOrokin    AlertMissionFactionKey = "Orokin"
	AlertMissionFactionKeyTenno     AlertMissionFactionKey = "Tenno"
)

// Defines values for AlertMissionType.
const (
	AlertMissionTypeAncientRetribution    AlertMissionType = "Ancient Retribution"
	AlertMissionTypeArena                 AlertMissionType = "Arena"
	AlertMissionTypeAssassination         AlertMissionType = "Assassination"
	AlertMissionTypeAssault               AlertMissionType = "Assault"
	AlertMissionTypeCapture               AlertMissionType = "Capture"
	AlertMissionTypeConclave              AlertMissionType = "Conclave"
	AlertMissionTypeDarkSectorDefection   AlertMissionType = "Dark Sector Defection"
	AlertMissionTypeDarkSectorDefense     AlertMissionType = "Dark Sector Defense"
	AlertMissionTypeDarkSectorDisruption  AlertMissionType = "Dark Sector Disruption"
	AlertMissionTypeDarkSectorExcavation  AlertMissionType = "Dark Sector Excavation"
	AlertMissionTypeDarkSectorSabotage    AlertMissionType = "Dark Sector Sabotage"
	AlertMissionTypeDarkSectorSurvival    AlertMissionType = "Dark Sector Survival"
	AlertMissionTypeDefense               AlertMissionType = "Defense"
	AlertMissionTypeDisruption            AlertMissionType = "Disruption"
	AlertMissionTypeExcavation            AlertMissionType = "Excavation"
	AlertMissionTypeExtermination         AlertMissionType = "Extermination"
	AlertMissionTypeExterminationArchwing AlertMissionType = "Extermination (Archwing)"
	AlertMissionTypeFreeRoam              AlertMissionType = "Free Roam"
	AlertMissionTypeHijack                AlertMissionType = "Hijack"
	AlertMissionTypeHive                  AlertMissionType = "Hive"
	AlertMissionTypeHiveSabotage          AlertMissionType = "Hive Sabotage"
	AlertMissionTypeInterception          AlertMissionType = "Interception"
	AlertMissionTypeInterceptionArchwing  AlertMissionType = "Interception (Archwing)"
	AlertMissionTypeMobileDefense         AlertMissionType = "Mobile Defense"
	AlertMissionTypeMobileDefenseArchwing AlertMissionType = "Mobile Defense (Archwing)"
	AlertMissionTypeOrokinSabotage        AlertMissionType = "Orokin Sabotage"
	AlertMissionTypeOrphix                AlertMissionType = "Orphix"
	AlertMissionTypePursuitArchwing       AlertMissionType = "Pursuit (Archwing)"
	AlertMissionTypeRelay                 AlertMissionType = "Relay"
	AlertMissionTypeRescue                AlertMissionType = "Rescue"
	AlertMissionTypeRushArchwing          AlertMissionType = "Rush (Archwing)"
	AlertMissionTypeSabotage              AlertMissionType = "Sabotage"
	AlertMissionTypeSabotageArchwing      AlertMissionType = "Sabotage (Archwing)"
	AlertMissionTypeSkirmish              AlertMissionType = "Skirmish"
	AlertMissionTypeSpy                   AlertMissionType = "Spy"
	AlertMissionTypeSurvival              AlertMissionType = "Survival"
	AlertMissionTypeVolatile              AlertMissionType = "Volatile"
)

// Defines values for AlertMissionTypeKey.
const (
	AlertMissionTypeKeyAncientRetribution    AlertMissionTypeKey = "Ancient Retribution"
	AlertMissionTypeKeyArena                 AlertMissionTypeKey = "Arena"
	AlertMissionTypeKeyAssassination         AlertMissionTypeKey = "Assassination"
	AlertMissionTypeKeyAssault               AlertMissionTypeKey = "Assault"
	AlertMissionTypeKeyCapture               AlertMissionTypeKey = "Capture"
	AlertMissionTypeKeyConclave              AlertMissionTypeKey = "Conclave"
	AlertMissionTypeKeyDarkSectorDefection   AlertMissionTypeKey = "Dark Sector Defection"
	AlertMissionTypeKeyDarkSectorDefense     AlertMissionTypeKey = "Dark Sector Defense"
	AlertMissionTypeKeyDarkSectorDisruption  AlertMissionTypeKey = "Dark Sector Disruption"
	AlertMissionTypeKeyDarkSectorExcavation  AlertMissionTypeKey = "Dark Sector Excavation"
	AlertMissionTypeKeyDarkSectorSabotage    AlertMissionTypeKey = "Dark Sector Sabotage"
	AlertMissionTypeKeyDarkSectorSurvival    AlertMissionTypeKey = "Dark Sector Survival"
	AlertMissionTypeKeyDefense               AlertMissionTypeKey = "Defense"
	AlertMissionTypeKeyDisruption            AlertMissionTypeKey = "Disruption"
	AlertMissionTypeKeyExcavation            AlertMissionTypeKey = "Excavation"
	AlertMissionTypeKeyExtermination         AlertMissionTypeKey = "Extermination"
	AlertMissionTypeKeyExterminationArchwing AlertMissionTypeKey = "Extermination (Archwing)"
	AlertMissionTypeKeyFreeRoam              AlertMissionTypeKey = "Free Roam"
	AlertMissionTypeKeyHijack                AlertMissionTypeKey = "Hijack"
	AlertMissionTypeKeyHive                  AlertMissionTypeKey = "Hive"
	AlertMissionTypeKeyHiveSabotage          AlertMissionTypeKey = "Hive Sabotage"
	AlertMissionTypeKeyInterception          AlertMissionTypeKey = "Interception"
	AlertMissionTypeKeyInterceptionArchwing  AlertMissionTypeKey = "Interception (Archwing)"
	AlertMissionTypeKeyMobileDefense         AlertMissionTypeKey = "Mobile Defense"
	AlertMissionTypeKeyMobileDefenseArchwing AlertMissionTypeKey = "Mobile Defense (Archwing)"
	AlertMissionTypeKeyOrokinSabotage        AlertMissionTypeKey = "Orokin Sabotage"
	AlertMissionTypeKeyOrphix                AlertMissionTypeKey = "Orphix"
	AlertMissionTypeKeyPursuitArchwing       AlertMissionTypeKey = "Pursuit (Archwing)"
	AlertMissionTypeKeyRelay                 AlertMissionTypeKey = "Relay"
	AlertMissionTypeKeyRescue                AlertMissionTypeKey = "Rescue"
	AlertMissionTypeKeyRushArchwing          AlertMissionTypeKey = "Rush (Archwing)"
	AlertMissionTypeKeySabotage              AlertMissionTypeKey = "Sabotage"
	AlertMissionTypeKeySabotageArchwing      AlertMissionTypeKey = "Sabotage (Archwing)"
	AlertMissionTypeKeySkirmish              AlertMissionTypeKey = "Skirmish"
	AlertMissionTypeKeySpy                   AlertMissionTypeKey = "Spy"
	AlertMissionTypeKeySurvival              AlertMissionTypeKey = "Survival"
	AlertMissionTypeKeyVolatile              AlertMissionTypeKey = "Volatile"
)

// Defines values for ArbitrationAllOfEnemy.
const (
	ArbitrationAllOfEnemyCorpus    ArbitrationAllOfEnemy = "Corpus"
	ArbitrationAllOfEnemyCorrupted ArbitrationAllOfEnemy = "Corrupted"
	ArbitrationAllOfEnemyGrineer   ArbitrationAllOfEnemy = "Grineer"
	ArbitrationAllOfEnemyInfested  ArbitrationAllOfEnemy = "Infested"
	ArbitrationAllOfEnemyNarmer    ArbitrationAllOfEnemy = "Narmer"
	ArbitrationAllOfEnemyOrokin    ArbitrationAllOfEnemy = "Orokin"
	ArbitrationAllOfEnemyTenno     ArbitrationAllOfEnemy = "Tenno"
)

// Defines values for ArbitrationAllOfEnemyKey.
const (
	ArbitrationAllOfEnemyKeyCorpus    ArbitrationAllOfEnemyKey = "Corpus"
	ArbitrationAllOfEnemyKeyCorrupted ArbitrationAllOfEnemyKey = "Corrupted"
	ArbitrationAllOfEnemyKeyGrineer   ArbitrationAllOfEnemyKey = "Grineer"
	ArbitrationAllOfEnemyKeyInfested  ArbitrationAllOfEnemyKey = "Infested"
	ArbitrationAllOfEnemyKeyNarmer    ArbitrationAllOfEnemyKey = "Narmer"
	ArbitrationAllOfEnemyKeyOrokin    ArbitrationAllOfEnemyKey = "Orokin"
	ArbitrationAllOfEnemyKeyTenno     ArbitrationAllOfEnemyKey = "Tenno"
)

// Defines values for ArchonHuntAllOfFaction.
const (
	ArchonHuntAllOfFactionCorpus    ArchonHuntAllOfFaction = "Corpus"
	ArchonHuntAllOfFactionCorrupted ArchonHuntAllOfFaction = "Corrupted"
	ArchonHuntAllOfFactionGrineer   ArchonHuntAllOfFaction = "Grineer"
	ArchonHuntAllOfFactionInfested  ArchonHuntAllOfFaction = "Infested"
	ArchonHuntAllOfFactionNarmer    ArchonHuntAllOfFaction = "Narmer"
	ArchonHuntAllOfFactionOrokin    ArchonHuntAllOfFaction = "Orokin"
	ArchonHuntAllOfFactionTenno     ArchonHuntAllOfFaction = "Tenno"
)

// Defines values for ArchonHuntAllOfFactionKey.
const (
	ArchonHuntAllOfFactionKeyCorpus    ArchonHuntAllOfFactionKey = "Corpus"
	ArchonHuntAllOfFactionKeyCorrupted ArchonHuntAllOfFactionKey = "Corrupted"
	ArchonHuntAllOfFactionKeyGrineer   ArchonHuntAllOfFactionKey = "Grineer"
	ArchonHuntAllOfFactionKeyInfested  ArchonHuntAllOfFactionKey = "Infested"
	ArchonHuntAllOfFactionKeyNarmer    ArchonHuntAllOfFactionKey = "Narmer"
	ArchonHuntAllOfFactionKeyOrokin    ArchonHuntAllOfFactionKey = "Orokin"
	ArchonHuntAllOfFactionKeyTenno     ArchonHuntAllOfFactionKey = "Tenno"
)

// Defines values for CambionCycleActive.
const (
	CambionCycleActiveFass CambionCycleActive = "fass"
	CambionCycleActiveVome CambionCycleActive = "vome"
)

// Defines values for CambionCycleState.
const (
	CambionCycleStateFass CambionCycleState = "fass"
	CambionCycleStateVome CambionCycleState = "vome"
)

// Defines values for Element.
const (
	Blast     Element = "blast"
	Cold      Element = "cold"
	Corrosive Element = "corrosive"
	Electric  Element = "electric"
	Gas       Element = "gas"
	Heat      Element = "heat"
	Impact    Element = "impact"
	Magnetic  Element = "magnetic"
	Puncture  Element = "puncture"
	Radiation Element = "radiation"
	Slash     Element = "slash"
	Toxin     Element = "toxin"
	True      Element = "true"
	Viral     Element = "viral"
	Void      Element = "void"
)

// Defines values for Faction.
const (
	FactionCorpus    Faction = "Corpus"
	FactionCorrupted Faction = "Corrupted"
	FactionGrineer   Faction = "Grineer"
	FactionInfested  Faction = "Infested"
	FactionNarmer    Faction = "Narmer"
	FactionOrokin    Faction = "Orokin"
	FactionTenno     Faction = "Tenno"
)

// Defines values for FissureEnemy.
const (
	FissureEnemyCorpus    FissureEnemy = "Corpus"
	FissureEnemyCorrupted FissureEnemy = "Corrupted"
	FissureEnemyGrineer   FissureEnemy = "Grineer"
	FissureEnemyInfested  FissureEnemy = "Infested"
	FissureEnemyNarmer    FissureEnemy = "Narmer"
	FissureEnemyOrokin    FissureEnemy = "Orokin"
	FissureEnemyTenno     FissureEnemy = "Tenno"
)

// Defines values for FissureEnemyKey.
const (
	FissureEnemyKeyCorpus    FissureEnemyKey = "Corpus"
	FissureEnemyKeyCorrupted FissureEnemyKey = "Corrupted"
	FissureEnemyKeyGrineer   FissureEnemyKey = "Grineer"
	FissureEnemyKeyInfested  FissureEnemyKey = "Infested"
	FissureEnemyKeyNarmer    FissureEnemyKey = "Narmer"
	FissureEnemyKeyOrokin    FissureEnemyKey = "Orokin"
	FissureEnemyKeyTenno     FissureEnemyKey = "Tenno"
)

// Defines values for FissureMissionKey.
const (
	FissureMissionKeyAncientRetribution    FissureMissionKey = "Ancient Retribution"
	FissureMissionKeyArena                 FissureMissionKey = "Arena"
	FissureMissionKeyAssassination         FissureMissionKey = "Assassination"
	FissureMissionKeyAssault               FissureMissionKey = "Assault"
	FissureMissionKeyCapture               FissureMissionKey = "Capture"
	FissureMissionKeyConclave              FissureMissionKey = "Conclave"
	FissureMissionKeyDarkSectorDefection   FissureMissionKey = "Dark Sector Defection"
	FissureMissionKeyDarkSectorDefense     FissureMissionKey = "Dark Sector Defense"
	FissureMissionKeyDarkSectorDisruption  FissureMissionKey = "Dark Sector Disruption"
	FissureMissionKeyDarkSectorExcavation  FissureMissionKey = "Dark Sector Excavation"
	FissureMissionKeyDarkSectorSabotage    FissureMissionKey = "Dark Sector Sabotage"
	FissureMissionKeyDarkSectorSurvival    FissureMissionKey = "Dark Sector Survival"
	FissureMissionKeyDefense               FissureMissionKey = "Defense"
	FissureMissionKeyDisruption            FissureMissionKey = "Disruption"
	FissureMissionKeyExcavation            FissureMissionKey = "Excavation"
	FissureMissionKeyExtermination         FissureMissionKey = "Extermination"
	FissureMissionKeyExterminationArchwing FissureMissionKey = "Extermination (Archwing)"
	FissureMissionKeyFreeRoam              FissureMissionKey = "Free Roam"
	FissureMissionKeyHijack                FissureMissionKey = "Hijack"
	FissureMissionKeyHive                  FissureMissionKey = "Hive"
	FissureMissionKeyHiveSabotage          FissureMissionKey = "Hive Sabotage"
	FissureMissionKeyInterception          FissureMissionKey = "Interception"
	FissureMissionKeyInterceptionArchwing  FissureMissionKey = "Interception (Archwing)"
	FissureMissionKeyMobileDefense         FissureMissionKey = "Mobile Defense"
	FissureMissionKeyMobileDefenseArchwing FissureMissionKey = "Mobile Defense (Archwing)"
	FissureMissionKeyOrokinSabotage        FissureMissionKey = "Orokin Sabotage"
	FissureMissionKeyOrphix                FissureMissionKey = "Orphix"
	FissureMissionKeyPursuitArchwing       FissureMissionKey = "Pursuit (Archwing)"
	FissureMissionKeyRelay                 FissureMissionKey = "Relay"
	FissureMissionKeyRescue                FissureMissionKey = "Rescue"
	FissureMissionKeyRushArchwing          FissureMissionKey = "Rush (Archwing)"
	FissureMissionKeySabotage              FissureMissionKey = "Sabotage"
	FissureMissionKeySabotageArchwing      FissureMissionKey = "Sabotage (Archwing)"
	FissureMissionKeySkirmish              FissureMissionKey = "Skirmish"
	FissureMissionKeySpy                   FissureMissionKey = "Spy"
	FissureMissionKeySurvival              FissureMissionKey = "Survival"
	FissureMissionKeyVolatile              FissureMissionKey = "Volatile"
)

// Defines values for FissureMissionType.
const (
	FissureMissionTypeAncientRetribution    FissureMissionType = "Ancient Retribution"
	FissureMissionTypeArena                 FissureMissionType = "Arena"
	FissureMissionTypeAssassination         FissureMissionType = "Assassination"
	FissureMissionTypeAssault               FissureMissionType = "Assault"
	FissureMissionTypeCapture               FissureMissionType = "Capture"
	FissureMissionTypeConclave              FissureMissionType = "Conclave"
	FissureMissionTypeDarkSectorDefection   FissureMissionType = "Dark Sector Defection"
	FissureMissionTypeDarkSectorDefense     FissureMissionType = "Dark Sector Defense"
	FissureMissionTypeDarkSectorDisruption  FissureMissionType = "Dark Sector Disruption"
	FissureMissionTypeDarkSectorExcavation  FissureMissionType = "Dark Sector Excavation"
	FissureMissionTypeDarkSectorSabotage    FissureMissionType = "Dark Sector Sabotage"
	FissureMissionTypeDarkSectorSurvival    FissureMissionType = "Dark Sector Survival"
	FissureMissionTypeDefense               FissureMissionType = "Defense"
	FissureMissionTypeDisruption            FissureMissionType = "Disruption"
	FissureMissionTypeExcavation            FissureMissionType = "Excavation"
	FissureMissionTypeExtermination         FissureMissionType = "Extermination"
	FissureMissionTypeExterminationArchwing FissureMissionType = "Extermination (Archwing)"
	FissureMissionTypeFreeRoam              FissureMissionType = "Free Roam"
	FissureMissionTypeHijack                FissureMissionType = "Hijack"
	FissureMissionTypeHive                  FissureMissionType = "Hive"
	FissureMissionTypeHiveSabotage          FissureMissionType = "Hive Sabotage"
	FissureMissionTypeInterception          FissureMissionType = "Interception"
	FissureMissionTypeInterceptionArchwing  FissureMissionType = "Interception (Archwing)"
	FissureMissionTypeMobileDefense         FissureMissionType = "Mobile Defense"
	FissureMissionTypeMobileDefenseArchwing FissureMissionType = "Mobile Defense (Archwing)"
	FissureMissionTypeOrokinSabotage        FissureMissionType = "Orokin Sabotage"
	FissureMissionTypeOrphix                FissureMissionType = "Orphix"
	FissureMissionTypePursuitArchwing       FissureMissionType = "Pursuit (Archwing)"
	FissureMissionTypeRelay                 FissureMissionType = "Relay"
	FissureMissionTypeRescue                FissureMissionType = "Rescue"
	FissureMissionTypeRushArchwing          FissureMissionType = "Rush (Archwing)"
	FissureMissionTypeSabotage              FissureMissionType = "Sabotage"
	FissureMissionTypeSabotageArchwing      FissureMissionType = "Sabotage (Archwing)"
	FissureMissionTypeSkirmish              FissureMissionType = "Skirmish"
	FissureMissionTypeSpy                   FissureMissionType = "Spy"
	FissureMissionTypeSurvival              FissureMissionType = "Survival"
	FissureMissionTypeVolatile              FissureMissionType = "Volatile"
)

// Defines values for FissureTier.
const (
	Axi     FissureTier = "Axi"
	Lith    FissureTier = "Lith"
	Meso    FissureTier = "Meso"
	Neo     FissureTier = "Neo"
	Requiem FissureTier = "Requiem"
)

// Defines values for FissuresInnerEnemy.
const (
	FissuresInnerEnemyCorpus    FissuresInnerEnemy = "Corpus"
	FissuresInnerEnemyCorrupted FissuresInnerEnemy = "Corrupted"
	FissuresInnerEnemyGrineer   FissuresInnerEnemy = "Grineer"
	FissuresInnerEnemyInfested  FissuresInnerEnemy = "Infested"
	FissuresInnerEnemyNarmer    FissuresInnerEnemy = "Narmer"
	FissuresInnerEnemyOrokin    FissuresInnerEnemy = "Orokin"
	FissuresInnerEnemyTenno     FissuresInnerEnemy = "Tenno"
)

// Defines values for FissuresInnerEnemyKey.
const (
	FissuresInnerEnemyKeyCorpus    FissuresInnerEnemyKey = "Corpus"
	FissuresInnerEnemyKeyCorrupted FissuresInnerEnemyKey = "Corrupted"
	FissuresInnerEnemyKeyGrineer   FissuresInnerEnemyKey = "Grineer"
	FissuresInnerEnemyKeyInfested  FissuresInnerEnemyKey = "Infested"
	FissuresInnerEnemyKeyNarmer    FissuresInnerEnemyKey = "Narmer"
	FissuresInnerEnemyKeyOrokin    FissuresInnerEnemyKey = "Orokin"
	FissuresInnerEnemyKeyTenno     FissuresInnerEnemyKey = "Tenno"
)

// Defines values for FissuresInnerMissionKey.
const (
	FissuresInnerMissionKeyAncientRetribution    FissuresInnerMissionKey = "Ancient Retribution"
	FissuresInnerMissionKeyArena                 FissuresInnerMissionKey = "Arena"
	FissuresInnerMissionKeyAssassination         FissuresInnerMissionKey = "Assassination"
	FissuresInnerMissionKeyAssault               FissuresInnerMissionKey = "Assault"
	FissuresInnerMissionKeyCapture               FissuresInnerMissionKey = "Capture"
	FissuresInnerMissionKeyConclave              FissuresInnerMissionKey = "Conclave"
	FissuresInnerMissionKeyDarkSectorDefection   FissuresInnerMissionKey = "Dark Sector Defection"
	FissuresInnerMissionKeyDarkSectorDefense     FissuresInnerMissionKey = "Dark Sector Defense"
	FissuresInnerMissionKeyDarkSectorDisruption  FissuresInnerMissionKey = "Dark Sector Disruption"
	FissuresInnerMissionKeyDarkSectorExcavation  FissuresInnerMissionKey = "Dark Sector Excavation"
	FissuresInnerMissionKeyDarkSectorSabotage    FissuresInnerMissionKey = "Dark Sector Sabotage"
	FissuresInnerMissionKeyDarkSectorSurvival    FissuresInnerMissionKey = "Dark Sector Survival"
	FissuresInnerMissionKeyDefense               FissuresInnerMissionKey = "Defense"
	FissuresInnerMissionKeyDisruption            FissuresInnerMissionKey = "Disruption"
	FissuresInnerMissionKeyExcavation            FissuresInnerMissionKey = "Excavation"
	FissuresInnerMissionKeyExtermination         FissuresInnerMissionKey = "Extermination"
	FissuresInnerMissionKeyExterminationArchwing FissuresInnerMissionKey = "Extermination (Archwing)"
	FissuresInnerMissionKeyFreeRoam              FissuresInnerMissionKey = "Free Roam"
	FissuresInnerMissionKeyHijack                FissuresInnerMissionKey = "Hijack"
	FissuresInnerMissionKeyHive                  FissuresInnerMissionKey = "Hive"
	FissuresInnerMissionKeyHiveSabotage          FissuresInnerMissionKey = "Hive Sabotage"
	FissuresInnerMissionKeyInterception          FissuresInnerMissionKey = "Interception"
	FissuresInnerMissionKeyInterceptionArchwing  FissuresInnerMissionKey = "Interception (Archwing)"
	FissuresInnerMissionKeyMobileDefense         FissuresInnerMissionKey = "Mobile Defense"
	FissuresInnerMissionKeyMobileDefenseArchwing FissuresInnerMissionKey = "Mobile Defense (Archwing)"
	FissuresInnerMissionKeyOrokinSabotage        FissuresInnerMissionKey = "Orokin Sabotage"
	FissuresInnerMissionKeyOrphix                FissuresInnerMissionKey = "Orphix"
	FissuresInnerMissionKeyPursuitArchwing       FissuresInnerMissionKey = "Pursuit (Archwing)"
	FissuresInnerMissionKeyRelay                 FissuresInnerMissionKey = "Relay"
	FissuresInnerMissionKeyRescue                FissuresInnerMissionKey = "Rescue"
	FissuresInnerMissionKeyRushArchwing          FissuresInnerMissionKey = "Rush (Archwing)"
	FissuresInnerMissionKeySabotage              FissuresInnerMissionKey = "Sabotage"
	FissuresInnerMissionKeySabotageArchwing      FissuresInnerMissionKey = "Sabotage (Archwing)"
	FissuresInnerMissionKeySkirmish              FissuresInnerMissionKey = "Skirmish"
	FissuresInnerMissionKeySpy                   FissuresInnerMissionKey = "Spy"
	FissuresInnerMissionKeySurvival              FissuresInnerMissionKey = "Survival"
	FissuresInnerMissionKeyVolatile              FissuresInnerMissionKey = "Volatile"
)

// Defines values for FissuresInnerMissionType.
const (
	FissuresInnerMissionTypeAncientRetribution    FissuresInnerMissionType = "Ancient Retribution"
	FissuresInnerMissionTypeArena                 FissuresInnerMissionType = "Arena"
	FissuresInnerMissionTypeAssassination         FissuresInnerMissionType = "Assassination"
	FissuresInnerMissionTypeAssault               FissuresInnerMissionType = "Assault"
	FissuresInnerMissionTypeCapture               FissuresInnerMissionType = "Capture"
	FissuresInnerMissionTypeConclave              FissuresInnerMissionType = "Conclave"
	FissuresInnerMissionTypeDarkSectorDefection   FissuresInnerMissionType = "Dark Sector Defection"
	FissuresInnerMissionTypeDarkSectorDefense     FissuresInnerMissionType = "Dark Sector Defense"
	FissuresInnerMissionTypeDarkSectorDisruption  FissuresInnerMissionType = "Dark Sector Disruption"
	FissuresInnerMissionTypeDarkSectorExcavation  FissuresInnerMissionType = "Dark Sector Excavation"
	FissuresInnerMissionTypeDarkSectorSabotage    FissuresInnerMissionType = "Dark Sector Sabotage"
	FissuresInnerMissionTypeDarkSectorSurvival    FissuresInnerMissionType = "Dark Sector Survival"
	FissuresInnerMissionTypeDefense               FissuresInnerMissionType = "Defense"
	FissuresInnerMissionTypeDisruption            FissuresInnerMissionType = "Disruption"
	FissuresInnerMissionTypeExcavation            FissuresInnerMissionType = "Excavation"
	FissuresInnerMissionTypeExtermination         FissuresInnerMissionType = "Extermination"
	FissuresInnerMissionTypeExterminationArchwing FissuresInnerMissionType = "Extermination (Archwing)"
	FissuresInnerMissionTypeFreeRoam              FissuresInnerMissionType = "Free Roam"
	FissuresInnerMissionTypeHijack                FissuresInnerMissionType = "Hijack"
	FissuresInnerMissionTypeHive                  FissuresInnerMissionType = "Hive"
	FissuresInnerMissionTypeHiveSabotage          FissuresInnerMissionType = "Hive Sabotage"
	FissuresInnerMissionTypeInterception          FissuresInnerMissionType = "Interception"
	FissuresInnerMissionTypeInterceptionArchwing  FissuresInnerMissionType = "Interception (Archwing)"
	FissuresInnerMissionTypeMobileDefense         FissuresInnerMissionType = "Mobile Defense"
	FissuresInnerMissionTypeMobileDefenseArchwing FissuresInnerMissionType = "Mobile Defense (Archwing)"
	FissuresInnerMissionTypeOrokinSabotage        FissuresInnerMissionType = "Orokin Sabotage"
	FissuresInnerMissionTypeOrphix                FissuresInnerMissionType = "Orphix"
	FissuresInnerMissionTypePursuitArchwing       FissuresInnerMissionType = "Pursuit (Archwing)"
	FissuresInnerMissionTypeRelay                 FissuresInnerMissionType = "Relay"
	FissuresInnerMissionTypeRescue                FissuresInnerMissionType = "Rescue"
	FissuresInnerMissionTypeRushArchwing          FissuresInnerMissionType = "Rush (Archwing)"
	FissuresInnerMissionTypeSabotage              FissuresInnerMissionType = "Sabotage"
	FissuresInnerMissionTypeSabotageArchwing      FissuresInnerMissionType = "Sabotage (Archwing)"
	FissuresInnerMissionTypeSkirmish              FissuresInnerMissionType = "Skirmish"
	FissuresInnerMissionTypeSpy                   FissuresInnerMissionType = "Spy"
	FissuresInnerMissionTypeSurvival              FissuresInnerMissionType = "Survival"
	FissuresInnerMissionTypeVolatile              FissuresInnerMissionType = "Volatile"
)

// Defines values for InvasionFactionFaction.
const (
	InvasionFactionFactionCorpus    InvasionFactionFaction = "Corpus"
	InvasionFactionFactionCorrupted InvasionFactionFaction = "Corrupted"
	InvasionFactionFactionGrineer   InvasionFactionFaction = "Grineer"
	InvasionFactionFactionInfested  InvasionFactionFaction = "Infested"
	InvasionFactionFactionNarmer    InvasionFactionFaction = "Narmer"
	InvasionFactionFactionOrokin    InvasionFactionFaction = "Orokin"
	InvasionFactionFactionTenno     InvasionFactionFaction = "Tenno"
)

// Defines values for InvasionFactionFactionKey.
const (
	InvasionFactionFactionKeyCorpus    InvasionFactionFactionKey = "Corpus"
	InvasionFactionFactionKeyCorrupted InvasionFactionFactionKey = "Corrupted"
	InvasionFactionFactionKeyGrineer   InvasionFactionFactionKey = "Grineer"
	InvasionFactionFactionKeyInfested  InvasionFactionFactionKey = "Infested"
	InvasionFactionFactionKeyNarmer    InvasionFactionFactionKey = "Narmer"
	InvasionFactionFactionKeyOrokin    InvasionFactionFactionKey = "Orokin"
	InvasionFactionFactionKeyTenno     InvasionFactionFactionKey = "Tenno"
)

// Defines values for InvasionAllOfAttackerFaction.
const (
	InvasionAllOfAttackerFactionCorpus    InvasionAllOfAttackerFaction = "Corpus"
	InvasionAllOfAttackerFactionCorrupted InvasionAllOfAttackerFaction = "Corrupted"
	InvasionAllOfAttackerFactionGrineer   InvasionAllOfAttackerFaction = "Grineer"
	InvasionAllOfAttackerFactionInfested  InvasionAllOfAttackerFaction = "Infested"
	InvasionAllOfAttackerFactionNarmer    InvasionAllOfAttackerFaction = "Narmer"
	InvasionAllOfAttackerFactionOrokin    InvasionAllOfAttackerFaction = "Orokin"
	InvasionAllOfAttackerFactionTenno     InvasionAllOfAttackerFaction = "Tenno"
)

// Defines values for InvasionAllOfAttackerFactionKey.
const (
	InvasionAllOfAttackerFactionKeyCorpus    InvasionAllOfAttackerFactionKey = "Corpus"
	InvasionAllOfAttackerFactionKeyCorrupted InvasionAllOfAttackerFactionKey = "Corrupted"
	InvasionAllOfAttackerFactionKeyGrineer   InvasionAllOfAttackerFactionKey = "Grineer"
	InvasionAllOfAttackerFactionKeyInfested  InvasionAllOfAttackerFactionKey = "Infested"
	InvasionAllOfAttackerFactionKeyNarmer    InvasionAllOfAttackerFactionKey = "Narmer"
	InvasionAllOfAttackerFactionKeyOrokin    InvasionAllOfAttackerFactionKey = "Orokin"
	InvasionAllOfAttackerFactionKeyTenno     InvasionAllOfAttackerFactionKey = "Tenno"
)

// Defines values for InvasionAllOfDefenderFaction.
const (
	InvasionAllOfDefenderFactionCorpus    InvasionAllOfDefenderFaction = "Corpus"
	InvasionAllOfDefenderFactionCorrupted InvasionAllOfDefenderFaction = "Corrupted"
	InvasionAllOfDefenderFactionGrineer   InvasionAllOfDefenderFaction = "Grineer"
	InvasionAllOfDefenderFactionInfested  InvasionAllOfDefenderFaction = "Infested"
	InvasionAllOfDefenderFactionNarmer    InvasionAllOfDefenderFaction = "Narmer"
	InvasionAllOfDefenderFactionOrokin    InvasionAllOfDefenderFaction = "Orokin"
	InvasionAllOfDefenderFactionTenno     InvasionAllOfDefenderFaction = "Tenno"
)

// Defines values for InvasionAllOfDefenderFactionKey.
const (
	InvasionAllOfDefenderFactionKeyCorpus    InvasionAllOfDefenderFactionKey = "Corpus"
	InvasionAllOfDefenderFactionKeyCorrupted InvasionAllOfDefenderFactionKey = "Corrupted"
	InvasionAllOfDefenderFactionKeyGrineer   InvasionAllOfDefenderFactionKey = "Grineer"
	InvasionAllOfDefenderFactionKeyInfested  InvasionAllOfDefenderFactionKey = "Infested"
	InvasionAllOfDefenderFactionKeyNarmer    InvasionAllOfDefenderFactionKey = "Narmer"
	InvasionAllOfDefenderFactionKeyOrokin    InvasionAllOfDefenderFactionKey = "Orokin"
	InvasionAllOfDefenderFactionKeyTenno     InvasionAllOfDefenderFactionKey = "Tenno"
)

// Defines values for Language.
const (
	De Language = "de"
	En Language = "en"
	Es Language = "es"
	Fr Language = "fr"
	It Language = "it"
	Ko Language = "ko"
	Pl Language = "pl"
	Pt Language = "pt"
	Ru Language = "ru"
	Uk Language = "uk"
	Zh Language = "zh"
)

// Defines values for MissionFaction.
const (
	MissionFactionCorpus    MissionFaction = "Corpus"
	MissionFactionCorrupted MissionFaction = "Corrupted"
	MissionFactionGrineer   MissionFaction = "Grineer"
	MissionFactionInfested  MissionFaction = "Infested"
	MissionFactionNarmer    MissionFaction = "Narmer"
	MissionFactionOrokin    MissionFaction = "Orokin"
	MissionFactionTenno     MissionFaction = "Tenno"
)

// Defines values for MissionFactionKey.
const (
	MissionFactionKeyCorpus    MissionFactionKey = "Corpus"
	MissionFactionKeyCorrupted MissionFactionKey = "Corrupted"
	MissionFactionKeyGrineer   MissionFactionKey = "Grineer"
	MissionFactionKeyInfested  MissionFactionKey = "Infested"
	MissionFactionKeyNarmer    MissionFactionKey = "Narmer"
	MissionFactionKeyOrokin    MissionFactionKey = "Orokin"
	MissionFactionKeyTenno     MissionFactionKey = "Tenno"
)

// Defines values for MissionType.
const (
	MissionTypeAncientRetribution    MissionType = "Ancient Retribution"
	MissionTypeArena                 MissionType = "Arena"
	MissionTypeAssassination         MissionType = "Assassination"
	MissionTypeAssault               MissionType = "Assault"
	MissionTypeCapture               MissionType = "Capture"
	MissionTypeConclave              MissionType = "Conclave"
	MissionTypeDarkSectorDefection   MissionType = "Dark Sector Defection"
	MissionTypeDarkSectorDefense     MissionType = "Dark Sector Defense"
	MissionTypeDarkSectorDisruption  MissionType = "Dark Sector Disruption"
	MissionTypeDarkSectorExcavation  MissionType = "Dark Sector Excavation"
	MissionTypeDarkSectorSabotage    MissionType = "Dark Sector Sabotage"
	MissionTypeDarkSectorSurvival    MissionType = "Dark Sector Survival"
	MissionTypeDefense               MissionType = "Defense"
	MissionTypeDisruption            MissionType = "Disruption"
	MissionTypeExcavation            MissionType = "Excavation"
	MissionTypeExtermination         MissionType = "Extermination"
	MissionTypeExterminationArchwing MissionType = "Extermination (Archwing)"
	MissionTypeFreeRoam              MissionType = "Free Roam"
	MissionTypeHijack                MissionType = "Hijack"
	MissionTypeHive                  MissionType = "Hive"
	MissionTypeHiveSabotage          MissionType = "Hive Sabotage"
	MissionTypeInterception          MissionType = "Interception"
	MissionTypeInterceptionArchwing  MissionType = "Interception (Archwing)"
	MissionTypeMobileDefense         MissionType = "Mobile Defense"
	MissionTypeMobileDefenseArchwing MissionType = "Mobile Defense (Archwing)"
	MissionTypeOrokinSabotage        MissionType = "Orokin Sabotage"
	MissionTypeOrphix                MissionType = "Orphix"
	MissionTypePursuitArchwing       MissionType = "Pursuit (Archwing)"
	MissionTypeRelay                 MissionType = "Relay"
	MissionTypeRescue                MissionType = "Rescue"
	MissionTypeRushArchwing          MissionType = "Rush (Archwing)"
	MissionTypeSabotage              MissionType = "Sabotage"
	MissionTypeSabotageArchwing      MissionType = "Sabotage (Archwing)"
	MissionTypeSkirmish              MissionType = "Skirmish"
	MissionTypeSpy                   MissionType = "Spy"
	MissionTypeSurvival              MissionType = "Survival"
	MissionTypeVolatile              MissionType = "Volatile"
)

// Defines values for MissionTypeKey.
const (
	MissionTypeKeyAncientRetribution    MissionTypeKey = "Ancient Retribution"
	MissionTypeKeyArena                 MissionTypeKey = "Arena"
	MissionTypeKeyAssassination         MissionTypeKey = "Assassination"
	MissionTypeKeyAssault               MissionTypeKey = "Assault"
	MissionTypeKeyCapture               MissionTypeKey = "Capture"
	MissionTypeKeyConclave              MissionTypeKey = "Conclave"
	MissionTypeKeyDarkSectorDefection   MissionTypeKey = "Dark Sector Defection"
	MissionTypeKeyDarkSectorDefense     MissionTypeKey = "Dark Sector Defense"
	MissionTypeKeyDarkSectorDisruption  MissionTypeKey = "Dark Sector Disruption"
	MissionTypeKeyDarkSectorExcavation  MissionTypeKey = "Dark Sector Excavation"
	MissionTypeKeyDarkSectorSabotage    MissionTypeKey = "Dark Sector Sabotage"
	MissionTypeKeyDarkSectorSurvival    MissionTypeKey = "Dark Sector Survival"
	MissionTypeKeyDefense               MissionTypeKey = "Defense"
	MissionTypeKeyDisruption            MissionTypeKey = "Disruption"
	MissionTypeKeyExcavation            MissionTypeKey = "Excavation"
	MissionTypeKeyExtermination         MissionTypeKey = "Extermination"
	MissionTypeKeyExterminationArchwing MissionTypeKey = "Extermination (Archwing)"
	MissionTypeKeyFreeRoam              MissionTypeKey = "Free Roam"
	MissionTypeKeyHijack                MissionTypeKey = "Hijack"
	MissionTypeKeyHive                  MissionTypeKey = "Hive"
	MissionTypeKeyHiveSabotage          MissionTypeKey = "Hive Sabotage"
	MissionTypeKeyInterception          MissionTypeKey = "Interception"
	MissionTypeKeyInterceptionArchwing  MissionTypeKey = "Interception (Archwing)"
	MissionTypeKeyMobileDefense         MissionTypeKey = "Mobile Defense"
	MissionTypeKeyMobileDefenseArchwing MissionTypeKey = "Mobile Defense (Archwing)"
	MissionTypeKeyOrokinSabotage        MissionTypeKey = "Orokin Sabotage"
	MissionTypeKeyOrphix                MissionTypeKey = "Orphix"
	MissionTypeKeyPursuitArchwing       MissionTypeKey = "Pursuit (Archwing)"
	MissionTypeKeyRelay                 MissionTypeKey = "Relay"
	MissionTypeKeyRescue                MissionTypeKey = "Rescue"
	MissionTypeKeyRushArchwing          MissionTypeKey = "Rush (Archwing)"
	MissionTypeKeySabotage              MissionTypeKey = "Sabotage"
	MissionTypeKeySabotageArchwing      MissionTypeKey = "Sabotage (Archwing)"
	MissionTypeKeySkirmish              MissionTypeKey = "Skirmish"
	MissionTypeKeySpy                   MissionTypeKey = "Spy"
	MissionTypeKeySurvival              MissionTypeKey = "Survival"
	MissionTypeKeyVolatile              MissionTypeKey = "Volatile"
)

// Defines values for MissionCategory.
const (
	MissionCategoryAncientRetribution    MissionCategory = "Ancient Retribution"
	MissionCategoryArena                 MissionCategory = "Arena"
	MissionCategoryAssassination         MissionCategory = "Assassination"
	MissionCategoryAssault               MissionCategory = "Assault"
	MissionCategoryCapture               MissionCategory = "Capture"
	MissionCategoryConclave              MissionCategory = "Conclave"
	MissionCategoryDarkSectorDefection   MissionCategory = "Dark Sector Defection"
	MissionCategoryDarkSectorDefense     MissionCategory = "Dark Sector Defense"
	MissionCategoryDarkSectorDisruption  MissionCategory = "Dark Sector Disruption"
	MissionCategoryDarkSectorExcavation  MissionCategory = "Dark Sector Excavation"
	MissionCategoryDarkSectorSabotage    MissionCategory = "Dark Sector Sabotage"
	MissionCategoryDarkSectorSurvival    MissionCategory = "Dark Sector Survival"
	MissionCategoryDefense               MissionCategory = "Defense"
	MissionCategoryDisruption            MissionCategory = "Disruption"
	MissionCategoryExcavation            MissionCategory = "Excavation"
	MissionCategoryExtermination         MissionCategory = "Extermination"
	MissionCategoryExterminationArchwing MissionCategory = "Extermination (Archwing)"
	MissionCategoryFreeRoam              MissionCategory = "Free Roam"
	MissionCategoryHijack                MissionCategory = "Hijack"
	MissionCategoryHive                  MissionCategory = "Hive"
	MissionCategoryHiveSabotage          MissionCategory = "Hive Sabotage"
	MissionCategoryInterception          MissionCategory = "Interception"
	MissionCategoryInterceptionArchwing  MissionCategory = "Interception (Archwing)"
	MissionCategoryMobileDefense         MissionCategory = "Mobile Defense"
	MissionCategoryMobileDefenseArchwing MissionCategory = "Mobile Defense (Archwing)"
	MissionCategoryOrokinSabotage        MissionCategory = "Orokin Sabotage"
	MissionCategoryOrphix                MissionCategory = "Orphix"
	MissionCategoryPursuitArchwing       MissionCategory = "Pursuit (Archwing)"
	MissionCategoryRelay                 MissionCategory = "Relay"
	MissionCategoryRescue                MissionCategory = "Rescue"
	MissionCategoryRushArchwing          MissionCategory = "Rush (Archwing)"
	MissionCategorySabotage              MissionCategory = "Sabotage"
	MissionCategorySabotageArchwing      MissionCategory = "Sabotage (Archwing)"
	MissionCategorySkirmish              MissionCategory = "Skirmish"
	MissionCategorySpy                   MissionCategory = "Spy"
	MissionCategorySurvival              MissionCategory = "Survival"
	MissionCategoryVolatile              MissionCategory = "Volatile"
)

// Defines values for Platform.
const (
	Pc  Platform = "pc"
	Ps4 Platform = "ps4"
	Swi Platform = "swi"
	Xb1 Platform = "xb1"
)

// Defines values for Polarity.
const (
	Madurai Polarity = "Madurai"
	Naramon Polarity = "Naramon"
	Penjaga Polarity = "Penjaga"
	Unairu  Polarity = "Unairu"
	Unbra   Polarity = "Unbra"
	Vazarin Polarity = "Vazarin"
	Zenurik Polarity = "Zenurik"
)

// Defines values for RewardType.
const (
	RewardTypeAlloyPlate    RewardType = "alloyPlate"
	RewardTypeArgonCrystal  RewardType = "argonCrystal"
	RewardTypeAura          RewardType = "aura"
	RewardTypeCatalyst      RewardType = "catalyst"
	RewardTypeCircuits      RewardType = "circuits"
	RewardTypeControlModule RewardType = "controlModule"
	RewardTypeCredits       RewardType = "credits"
	RewardTypeCryotic       RewardType = "cryotic"
	RewardTypeDetonite      RewardType = "detonite"
	RewardTypeEndo          RewardType = "endo"
	RewardTypeExilus        RewardType = "exilus"
	RewardTypeFerrite       RewardType = "ferrite"
	RewardTypeFieldron      RewardType = "fieldron"
	RewardTypeForma         RewardType = "forma"
	RewardTypeGallium       RewardType = "gallium"
	RewardTypeHelmet        RewardType = "helmet"
	RewardTypeKavatGene     RewardType = "kavatGene"
	RewardTypeKubrowEgg     RewardType = "kubrowEgg"
	RewardTypeMorphics      RewardType = "morphics"
	RewardTypeMutagen       RewardType = "mutagen"
	RewardTypeMutalist      RewardType = "mutalist"
	RewardTypeNanoSpores    RewardType = "nanoSpores"
	RewardTypeNeuralSensors RewardType = "neuralSensors"
	RewardTypeNeurodes      RewardType = "neurodes"
	RewardTypeNightmare     RewardType = "nightmare"
	RewardTypeNitain        RewardType = "nitain"
	RewardTypeOrokinCell    RewardType = "orokinCell"
	RewardTypeOther         RewardType = "other"
	RewardTypeOxium         RewardType = "oxium"
	RewardTypePlastids      RewardType = "plastids"
	RewardTypePolymerBundle RewardType = "polymerBundle"
	RewardTypeReactor       RewardType = "reactor"
	RewardTypeRiven         RewardType = "riven"
	RewardTypeRubedo        RewardType = "rubedo"
	RewardTypeSalvage       RewardType = "salvage"
	RewardTypeSkin          RewardType = "skin"
	RewardTypeSynthula      RewardType = "synthula"
	RewardTypeTellurium     RewardType = "tellurium"
	RewardTypeTraces        RewardType = "traces"
	RewardTypeVandal        RewardType = "vandal"
	RewardTypeVauban        RewardType = "vauban"
	RewardTypeWeapon        RewardType = "weapon"
	RewardTypeWraith        RewardType = "wraith"
)

// Defines values for SortieAllOfFaction.
const (
	SortieAllOfFactionCorpus    SortieAllOfFaction = "Corpus"
	SortieAllOfFactionCorrupted SortieAllOfFaction = "Corrupted"
	SortieAllOfFactionGrineer   SortieAllOfFaction = "Grineer"
	SortieAllOfFactionInfested  SortieAllOfFaction = "Infested"
	SortieAllOfFactionNarmer    SortieAllOfFaction = "Narmer"
	SortieAllOfFactionOrokin    SortieAllOfFaction = "Orokin"
	SortieAllOfFactionTenno     SortieAllOfFaction = "Tenno"
)

// Defines values for SortieAllOfFactionKey.
const (
	Corpus    SortieAllOfFactionKey = "Corpus"
	Corrupted SortieAllOfFactionKey = "Corrupted"
	Grineer   SortieAllOfFactionKey = "Grineer"
	Infested  SortieAllOfFactionKey = "Infested"
	Narmer    SortieAllOfFactionKey = "Narmer"
	Orokin    SortieAllOfFactionKey = "Orokin"
	Tenno     SortieAllOfFactionKey = "Tenno"
)

// Defines values for Syndicate.
const (
	SyndicateArbitersOfHexis Syndicate = "Arbiters of Hexis"
	SyndicateAssassins       Syndicate = "Assassins"
	SyndicateCephalonSuda    Syndicate = "Cephalon Suda"
	SyndicateNewLoka         Syndicate = "New Loka"
	SyndicateNightwave       Syndicate = "Nightwave"
	SyndicateOstrons         Syndicate = "Ostrons"
	SyndicatePerrinSequence  Syndicate = "Perrin Sequence"
	SyndicateRedVeil         Syndicate = "Red Veil"
	SyndicateSolarisUnited   Syndicate = "Solaris United"
	SyndicateSteelMeridian   Syndicate = "Steel Meridian"
	SyndicateVoxSolaris      Syndicate = "Vox Solaris"
)

// AcolyteI18n defines model for acolyteI18n.
type AcolyteI18n struct {
	Region *[]string `json:"region,omitempty"`
}

// Alert defines model for alert.
type Alert struct {
	// Eta Short-formatted string estimating the time until the event/mission is closed
	Eta         *string      `json:"eta,omitempty"`
	Expired     bool         `json:"expired"`
	Mission     AlertMission `json:"mission"`
	RewardTypes []RewardType `json:"rewardTypes"`
}

// AlertMission defines model for alert_mission.
type AlertMission struct {
	// AdvancedSpawners Array of strings denoting extra spawners for a mission
	AdvancedSpawners *[]string `json:"advancedSpawners,omitempty"`

	// ArchwingRequired Whether an Archwing is required for participating in the mision.
	ArchwingRequired bool `json:"archwingRequired"`

	// ConsumeRequiredItems Whether the required items are consumed
	ConsumeRequiredItems *bool `json:"consumeRequiredItems,omitempty"`

	// Description Description of the mission
	Description string `json:"description"`

	// EnemySpec Enemy specification for the mission
	EnemySpec  *string                 `json:"enemySpec,omitempty"`
	Faction    AlertMissionFaction     `json:"faction"`
	FactionKey *AlertMissionFactionKey `json:"factionKey,omitempty"`

	// IsSharkwing Whether the mission takes place in a submerssible mission.
	IsSharkwing *bool `json:"isSharkwing,omitempty"`

	// LeadersAlwaysAllowed Whether leaders are always allowed
	LeadersAlwaysAllowed *bool `json:"leadersAlwaysAllowed,omitempty"`

	// LevelAuras Affectors for this mission
	LevelAuras *[]string `json:"levelAuras,omitempty"`

	// LevelOverride Override for the map on this mission
	LevelOverride *string `json:"levelOverride,omitempty"`
	MaxEnemyLevel float32 `json:"maxEnemyLevel"`
	MaxWaveNum    float32 `json:"maxWaveNum"`
	MinEnemyLevel float32 `json:"minEnemyLevel"`
	Nightmare     bool    `json:"nightmare"`
	Node          string  `json:"node"`

	// NodeKey Unlocalized node
	NodeKey *string `json:"nodeKey,omitempty"`

	// RequiredItems Items required to enter the mission
	RequiredItems *[]string            `json:"requiredItems,omitempty"`
	Reward        Reward               `json:"reward"`
	Type          AlertMissionType     `json:"type"`
	TypeKey       *AlertMissionTypeKey `json:"typeKey,omitempty"`
}

// AlertMissionFaction defines model for AlertMission.Faction.
type AlertMissionFaction string

// AlertMissionFactionKey defines model for AlertMission.FactionKey.
type AlertMissionFactionKey string

// AlertMissionType defines model for AlertMission.Type.
type AlertMissionType string

// AlertMissionTypeKey defines model for AlertMission.TypeKey.
type AlertMissionTypeKey string

// Alerts defines model for alerts.
type Alerts = []AlertsInner

// AlertsInner defines model for alerts_inner.
type AlertsInner struct {
	// Activation ISO-8601 formatted timestamp for when the event began
	Activation *time.Time `json:"activation,omitempty"`

	// Active Whether the event is currently active
	Active *bool `json:"active,omitempty"`

	// Eta Short-formatted string estimating the time until the event/mission is closed
	Eta     *string `json:"eta,omitempty"`
	Expired bool    `json:"expired"`

	// Expiry ISO-8601 formatted timestamp for when the event is expected to end
	Expiry *time.Time `json:"expiry,omitempty"`

	// Id unique identifier for this object/event/thing
	Id          *string      `json:"id,omitempty"`
	Mission     AlertMission `json:"mission"`
	RewardTypes []RewardType `json:"rewardTypes"`

	// StartString Short-time-formatted duration string representing the start of the event
	StartString *string `json:"startString,omitempty"`
}

// Arbitration defines model for arbitration.
type Arbitration struct {
	// Activation ISO-8601 formatted timestamp for when the event began
	Activation *time.Time `json:"activation,omitempty"`

	// Active Whether the event is currently active
	Active *bool `json:"active,omitempty"`

	// Archwing Whether this mission requires archwing
	Archwing *bool                     `json:"archwing,omitempty"`
	Enemy    *ArbitrationAllOfEnemy    `json:"enemy,omitempty"`
	EnemyKey *ArbitrationAllOfEnemyKey `json:"enemyKey,omitempty"`

	// Expiry ISO-8601 formatted timestamp for when the event is expected to end
	Expiry *time.Time `json:"expiry,omitempty"`

	// Id unique identifier for this object/event/thing
	Id *string `json:"id,omitempty"`

	// Node Plain name for the node
	Node *string `json:"node,omitempty"`

	// Sharkwing Whether this mission requires sharkwing
	Sharkwing *bool `json:"sharkwing,omitempty"`

	// StartString Short-time-formatted duration string representing the start of the event
	StartString *string `json:"startString,omitempty"`

	// Type Mission type localized
	Type    *string                  `json:"type,omitempty"`
	TypeKey *ArbitrationAllOfTypeKey `json:"typeKey,omitempty"`
}

// ArbitrationAllOfEnemy defines model for arbitration_allOf_enemy.
type ArbitrationAllOfEnemy string

// ArbitrationAllOfEnemyKey defines model for arbitration_allOf_enemyKey.
type ArbitrationAllOfEnemyKey string

// ArbitrationAllOfTypeKey defines model for arbitration_allOf_typeKey.
type ArbitrationAllOfTypeKey = interface{}

// Arcane defines model for arcane.
type Arcane struct {
	Effect    string `json:"effect"`
	Info      string `json:"info"`
	Location  string `json:"location"`
	Name      string `json:"name"`
	Rarity    string `json:"rarity"`
	Regex     string `json:"regex"`
	Thumbnail string `json:"thumbnail"`
}

// ArchonHunt defines model for archonHunt.
type ArchonHunt struct {
	// Activation ISO-8601 formatted timestamp for when the event began
	Activation time.Time `json:"activation"`

	// Active Whether the event is currently active
	Active  *bool  `json:"active,omitempty"`
	Boss    string `json:"boss"`
	Eta     string `json:"eta"`
	Expired bool   `json:"expired"`

	// Expiry ISO-8601 formatted timestamp for when the event is expected to end
	Expiry     time.Time                  `json:"expiry"`
	Faction    ArchonHuntAllOfFaction     `json:"faction"`
	FactionKey *ArchonHuntAllOfFactionKey `json:"factionKey,omitempty"`

	// Id unique identifier for this object/event/thing
	Id         string    `json:"id"`
	Missions   []Mission `json:"missions"`
	RewardPool string    `json:"rewardPool"`

	// StartString Short-time-formatted duration string representing the start of the event
	StartString *string `json:"startString,omitempty"`
}

// ArchonHuntAllOfFaction defines model for archonHunt_allOf_faction.
type ArchonHuntAllOfFaction string

// ArchonHuntAllOfFactionKey defines model for archonHunt_allOf_factionKey.
type ArchonHuntAllOfFactionKey string

// Attack defines model for attack.
type Attack struct {
	Channeling   *float32       `json:"channeling,omitempty"`
	ChargeTime   *float32       `json:"charge_time,omitempty"`
	CritChance   *float32       `json:"crit_chance,omitempty"`
	CritMult     *float32       `json:"crit_mult,omitempty"`
	Damage       *Damage        `json:"damage,omitempty"`
	Duration     *float32       `json:"duration,omitempty"`
	Falloff      *AttackFalloff `json:"falloff,omitempty"`
	Flight       *float32       `json:"flight,omitempty"`
	Jump         *string        `json:"jump,omitempty"`
	Name         *string        `json:"name,omitempty"`
	Pellet       *AttackPellet  `json:"pellet,omitempty"`
	Radius       *float32       `json:"radius,omitempty"`
	ShotSpeed    *float32       `json:"shot_speed,omitempty"`
	ShotType     *float32       `json:"shot_type,omitempty"`
	Slam         *SlamAttack    `json:"slam,omitempty"`
	Slide        *string        `json:"slide,omitempty"`
	Speed        *float32       `json:"speed,omitempty"`
	StatusChance *float32       `json:"status_chance,omitempty"`
	Wall         *string        `json:"wall,omitempty"`
}

// AttackFalloff defines model for attack_falloff.
type AttackFalloff struct {
	End       *float32 `json:"end,omitempty"`
	Reduction *float32 `json:"reduction,omitempty"`
	Start     *float32 `json:"start,omitempty"`
}

// AttackPellet defines model for attack_pellet.
type AttackPellet struct {
	Count *float32 `json:"count,omitempty"`
	Name  *string  `json:"name,omitempty"`
}

// CambionCycle defines model for cambionCycle.
type CambionCycle struct {
	Activation string `json:"activation"`
	// Deprecated:
	Active   *CambionCycleActive `json:"active,omitempty"`
	Expiry   string              `json:"expiry"`
	Id       string              `json:"id"`
	State    CambionCycleState   `json:"state"`
	TimeLeft *string             `json:"timeLeft,omitempty"`
}

// CambionCycleActive defines model for CambionCycle.Active.
type CambionCycleActive string

// CambionCycleState defines model for CambionCycle.State.
type CambionCycleState string

// CetusCycle defines model for cetusCycle.
type CetusCycle struct {
	// Activation ISO-8601 formatted timestamp for when the event began
	Activation *time.Time `json:"activation,omitempty"`

	// Active Whether the event is currently active
	Active *bool `json:"active,omitempty"`

	// Expiry ISO-8601 formatted timestamp for when the event is expected to end
	Expiry time.Time `json:"expiry"`

	// Id unique identifier for this object/event/thing
	Id      *string `json:"id,omitempty"`
	IsCetus bool    `json:"isCetus"`
	IsDay   bool    `json:"isDay"`

	// ShortString A short description of the remaining time until the next day/night change.
	ShortString *string `json:"shortString,omitempty"`

	// StartString Short-time-formatted duration string representing the start of the event
	StartString *string `json:"startString,omitempty"`

	// State Describes the current time. e.g. "day" or "night"
	State    *string `json:"state,omitempty"`
	TimeLeft string  `json:"timeLeft"`
}

// Conclave defines model for conclave.
type Conclave struct {
	Categories ConclaveCategories `json:"categories"`
	Modes      ConclaveModes      `json:"modes"`
}

// ConclaveChallenges defines model for conclaveChallenges.
type ConclaveChallenges = []ConclaveChallengesInner

// ConclaveChallengesInner defines model for conclaveChallenges_inner.
type ConclaveChallengesInner struct {
	Amount        float32 `json:"amount"`
	AsString      string  `json:"asString"`
	Category      string  `json:"category"`
	Daily         bool    `json:"daily"`
	Description   string  `json:"description"`
	EndString     string  `json:"endString"`
	Eta           string  `json:"eta"`
	Expired       bool    `json:"expired"`
	Expiry        string  `json:"expiry"`
	Id            string  `json:"id"`
	Mode          string  `json:"mode"`
	RootChallenge bool    `json:"rootChallenge"`
}

// ConclaveCategories defines model for conclave_categories.
type ConclaveCategories struct {
	PVPChallengeTypeCategoryDAILY        ConclaveModesPVPMODEALL `json:"PVPChallengeTypeCategory_DAILY"`
	PVPChallengeTypeCategoryDAILYROOT    ConclaveModesPVPMODEALL `json:"PVPChallengeTypeCategory_DAILY_ROOT"`
	PVPChallengeTypeCategoryMODEAFFECTOR ConclaveModesPVPMODEALL `json:"PVPChallengeTypeCategory_MODEAFFECTOR"`
	PVPChallengeTypeCategoryWEEKLY       ConclaveModesPVPMODEALL `json:"PVPChallengeTypeCategory_WEEKLY"`
	PVPChallengeTypeCategoryWEEKLYROOT   ConclaveModesPVPMODEALL `json:"PVPChallengeTypeCategory_WEEKLY_ROOT"`
}

// ConclaveModes defines model for conclave_modes.
type ConclaveModes struct {
	PVPMODEALL            ConclaveModesPVPMODEALL `json:"PVPMODE_ALL"`
	PVPMODECAPTURETHEFLAG ConclaveModesPVPMODEALL `json:"PVPMODE_CAPTURETHEFLAG"`
	PVPMODEDEATHMATCH     ConclaveModesPVPMODEALL `json:"PVPMODE_DEATHMATCH"`
	PVPMODENONE           ConclaveModesPVPMODEALL `json:"PVPMODE_NONE"`
	PVPMODESPEEDBALL      ConclaveModesPVPMODEALL `json:"PVPMODE_SPEEDBALL"`
	PVPMODETEAMDEATHMATCH ConclaveModesPVPMODEALL `json:"PVPMODE_TEAMDEATHMATCH"`
}

// ConclaveModesPVPMODEALL defines model for conclave_modes_PVPMODE_ALL.
type ConclaveModesPVPMODEALL struct {
	Value string `json:"value"`
}

// Construction defines model for construction.
type Construction struct {
	FomorianProgress  string `json:"fomorianProgress"`
	Id                string `json:"id"`
	RazorbackProgress string `json:"razorbackProgress"`
	UnknownProgress   string `json:"unknownProgress"`
}

// DailyDeals defines model for dailyDeals.
type DailyDeals = []DailyDealsInner

// DailyDealsInner defines model for dailyDeals_inner.
type DailyDealsInner struct {
	Discount      float32 `json:"discount"`
	Eta           string  `json:"eta"`
	Expiry        string  `json:"expiry"`
	Id            string  `json:"id"`
	Item          string  `json:"item"`
	OriginalPrice float32 `json:"originalPrice"`
	SalePrice     float32 `json:"salePrice"`
	Sold          float32 `json:"sold"`
	Total         float32 `json:"total"`
	UniqueName    string  `json:"uniqueName"`
}

// Damage defines model for damage.
type Damage struct {
	Blast     *float32 `json:"blast,omitempty"`
	Cold      *float32 `json:"cold,omitempty"`
	Corrosive *float32 `json:"corrosive,omitempty"`
	Electric  *float32 `json:"electric,omitempty"`
	Gas       *float32 `json:"gas,omitempty"`
	Heat      *float32 `json:"heat,omitempty"`
	Impact    *float32 `json:"impact,omitempty"`
	Magnetic  *float32 `json:"magnetic,omitempty"`
	Puncture  *float32 `json:"puncture,omitempty"`
	Radiation *float32 `json:"radiation,omitempty"`
	Slash     *float32 `json:"slash,omitempty"`
	Toxin     *float32 `json:"toxin,omitempty"`
	True      *float32 `json:"true,omitempty"`
	Viral     *float32 `json:"viral,omitempty"`
	Void      *float32 `json:"void,omitempty"`
}

// DarkSectorHistory Describes a Dark Sector Historical Battle.
type DarkSectorHistory struct {
	// Attacker Clan or alliance that was attacking.
	Attacker *string `json:"attacker,omitempty"`

	// Defender Clan or alliance that was defending.
	Defender *string `json:"defender,omitempty"`

	// DefenderIsAlliance Whether the defender was an alliance.
	DefenderIsAlliance *bool `json:"defenderIsAlliance,omitempty"`

	// End When the battle ended.
	End *string `json:"end,omitempty"`

	// Start When the battle started.
	Start *string `json:"start,omitempty"`

	// Winner One of attacker or defender, whichever one won.
	Winner *string `json:"winner,omitempty"`
}

// DarkSectors defines model for darkSectors.
type DarkSectors = []DarkSectorsInner

// DarkSectorsInner defines model for darkSectors_inner.
type DarkSectorsInner struct {
	DefenderDeploymentActivation *float32             `json:"defenderDeploymentActivation,omitempty"`
	DefenderMOTD                 string               `json:"defenderMOTD"`
	DefenderName                 string               `json:"defenderName"`
	DeployerClan                 string               `json:"deployerClan"`
	DeployerName                 string               `json:"deployerName"`
	History                      *[]DarkSectorHistory `json:"history,omitempty"`
	Id                           string               `json:"id"`
	IsAlliance                   bool                 `json:"isAlliance"`
}

// Drops defines model for drops.
type Drops = []DropsInner

// DropsInner defines model for drops_inner.
type DropsInner struct {
	Chance float32 `json:"chance"`
	Item   string  `json:"item"`
	Place  string  `json:"place"`
	Rarity string  `json:"rarity"`
}

// EarthCycle defines model for earthCycle.
type EarthCycle struct {
	// Activation ISO-8601 formatted timestamp for when the event began
	Activation *time.Time `json:"activation,omitempty"`

	// Active Whether the event is currently active
	Active *bool `json:"active,omitempty"`

	// Expiry ISO-8601 formatted timestamp for when the event is expected to end
	Expiry time.Time `json:"expiry"`

	// Id unique identifier for this object/event/thing
	Id    string `json:"id"`
	IsDay bool   `json:"isDay"`

	// StartString Short-time-formatted duration string representing the start of the event
	StartString *string `json:"startString,omitempty"`
	TimeLeft    string  `json:"timeLeft"`
}

// Element defines model for element.
type Element string

// Event defines model for event.
type Event struct {
	// Activation ISO-8601 formatted timestamp for when the event began
	Activation *time.Time `json:"activation,omitempty"`

	// Active Whether the event is currently active
	Active         *bool      `json:"active,omitempty"`
	AffiliatedWith *Syndicate `json:"affiliatedWith,omitempty"`

	// AltActivation Alternate Activation. Use unknown.
	AltActivation *time.Time `json:"altActivation,omitempty"`

	// AltExpiry Alternate Expiry. Use unknown.
	AltExpiry *time.Time `json:"altExpiry,omitempty"`

	// ArchwingDrops Archwing Drops in effect while this event is active
	ArchwingDrops *[]string `json:"archwingDrops,omitempty"`

	// AsString Attempt to summarize event in a short string. (Do not use).
	AsString *string `json:"asString,omitempty"`

	// CompletionBonuses Completion bonus amounts per-stage
	CompletionBonuses *[]float32 `json:"completionBonuses,omitempty"`

	// ConcurrentNodes Nodes that the event is happening concurrently on
	ConcurrentNodes *[]string `json:"concurrentNodes,omitempty"`

	// CurrentScore The current score for the event
	CurrentScore *float32 `json:"currentScore,omitempty"`

	// Description The description or "subtitle" for the event.
	Description *string `json:"description,omitempty"`

	// Expiry ISO-8601 formatted timestamp for when the event is expected to end
	Expiry *time.Time `json:"expiry,omitempty"`

	// Faction A Faction in Warframe
	Faction *Faction `json:"faction,omitempty"`

	// Health Amount of health remaining for the target
	Health *float32 `json:"health,omitempty"`

	// Id unique identifier for this object/event/thing
	Id *string `json:"id,omitempty"`

	// InterimSteps Interim steps, marking progress towards the final goal.
	InterimSteps *[]EventAllOfInterimSteps `json:"interimSteps,omitempty"`

	// IsCommunity Whether the event is communal
	IsCommunity *bool `json:"isCommunity,omitempty"`

	// IsPersonal Whether the event is personal
	IsPersonal *bool           `json:"isPersonal,omitempty"`
	Jobs       *[]SyndicateJob `json:"jobs,omitempty"`

	// LargeInterval Interval for the second intermediate score
	LargeInterval *float32 `json:"largeInterval,omitempty"`

	// MaximumScore Maximum score to complete the event
	MaximumScore *float32 `json:"maximumScore,omitempty"`

	// Metadata Miscellaneous metadata in a string provided by Digital Extremes
	Metadata *EventAllOfMetadata `json:"metadata,omitempty"`
	NextAlt  *EventAllOfNextAlt  `json:"nextAlt,omitempty"`

	// Node Node that the event is taking place on
	Node          *string                    `json:"node,omitempty"`
	ProgressSteps *[]EventAllOfProgressSteps `json:"progressSteps,omitempty"`

	// ProgressTotal Total of progressSteps values.
	ProgressTotal *float32 `json:"progressTotal,omitempty"`

	// RegionDrops Drops in the area around the event node
	RegionDrops *[]string `json:"regionDrops,omitempty"`
	Rewards     *[]Reward `json:"rewards,omitempty"`

	// ScoreLocTag Localized tag for the event score
	ScoreLocTag *string `json:"scoreLocTag,omitempty"`

	// ScoreVar Internal string used for unknown purpose
	ScoreVar *string `json:"scoreVar,omitempty"`

	// ShowTotalAtEndOfMission Whether to show the total score at the end of the mission
	ShowTotalAtEndOfMission *bool `json:"showTotalAtEndOfMission,omitempty"`

	// SmallInterval Interval for the first goal
	SmallInterval *float32 `json:"smallInterval,omitempty"`

	// StartString Short-time-formatted duration string representing the start of the event
	StartString *string `json:"startString,omitempty"`

	// Tooltip Tooltip for the event
	Tooltip *string `json:"tooltip,omitempty"`

	// VictimNode Node that is being attacked & defended in the event.
	VictimNode *string `json:"victimNode,omitempty"`
}

// EventAllOfInterimSteps defines model for event_allOf_interimSteps.
type EventAllOfInterimSteps struct {
	// Goal Score to each to achieve this step
	Goal    *float32           `json:"goal,omitempty"`
	Message *EventAllOfMessage `json:"message,omitempty"`
	Reward  *Reward            `json:"reward,omitempty"`

	// WinnerCount Suspected to be the number of persons who have completed this step.
	WinnerCount *float32 `json:"winnerCount,omitempty"`
}

// EventAllOfMessage defines model for event_allOf_message.
type EventAllOfMessage struct {
	// Attachments Attachments to the message. Unknown usage.
	Attachments *[]string `json:"attachments,omitempty"`

	// Message Body of the in-game mail received for completing the step.
	Message *string `json:"message,omitempty"`

	// Sender Who commissioned this reward
	Sender *string `json:"sender,omitempty"`

	// SenderIcon Path to sender icon string.
	SenderIcon *string `json:"senderIcon,omitempty"`

	// Subject Title of the in-game mail received for completing the step.
	Subject *string `json:"subject,omitempty"`
}

// EventAllOfMetadata Miscellaneous metadata in a string provided by Digital Extremes
type EventAllOfMetadata = map[string]interface{}

// EventAllOfNextAlt defines model for event_allOf_nextAlt.
type EventAllOfNextAlt struct {
	// Activation Next alternate activation. Use unknown.
	Activation *time.Time `json:"activation,omitempty"`

	// Expiry Next alternate expiry. Use unknown.
	Expiry *time.Time `json:"expiry,omitempty"`
}

// EventAllOfProgressSteps defines model for event_allOf_progressSteps.
type EventAllOfProgressSteps struct {
	// ProgressAmt Percent progress to completion
	ProgressAmt *float32 `json:"progressAmt,omitempty"`

	// Type Steps in the progress to completion
	Type *string `json:"type,omitempty"`
}

// Events defines model for events.
type Events = []Event

// Faction A Faction in Warframe
type Faction string

// Factions defines model for factions.
type Factions struct {
	FCCORPUS      ConclaveModesPVPMODEALL `json:"FC_CORPUS"`
	FCCORRUPTED   ConclaveModesPVPMODEALL `json:"FC_CORRUPTED"`
	FCGRINEER     ConclaveModesPVPMODEALL `json:"FC_GRINEER"`
	FCINFESTATION ConclaveModesPVPMODEALL `json:"FC_INFESTATION"`
	FCOROKIN      ConclaveModesPVPMODEALL `json:"FC_OROKIN"`
}

// Fissure defines model for fissure.
type Fissure struct {
	Enemy    FissureEnemy     `json:"enemy"`
	EnemyKey *FissureEnemyKey `json:"enemyKey,omitempty"`

	// Eta Short-formatted string estimating the time until the event/mission is closed
	Eta string `json:"eta"`

	// Expired Whether the fissure is still present
	Expired bool `json:"expired"`

	// IsHard Whether this fissure is on the Steel Path
	IsHard *bool `json:"isHard,omitempty"`

	// IsStorm Whether this fissure is a void storm
	IsStorm     *bool              `json:"isStorm,omitempty"`
	MissionKey  *FissureMissionKey `json:"missionKey,omitempty"`
	MissionType FissureMissionType `json:"missionType"`

	// Node Node name with planet
	Node string      `json:"node"`
	Tier interface{} `json:"tier"`

	// TierNum Numeric tier corresponding to the tier
	TierNum float32 `json:"tierNum"`
}

// FissureEnemy defines model for Fissure.Enemy.
type FissureEnemy string

// FissureEnemyKey defines model for Fissure.EnemyKey.
type FissureEnemyKey string

// FissureMissionKey defines model for Fissure.MissionKey.
type FissureMissionKey string

// FissureMissionType defines model for Fissure.MissionType.
type FissureMissionType string

// FissureModifiers defines model for fissureModifiers.
type FissureModifiers struct {
	VoidT1 FissureModifiersVoidT1 `json:"VoidT1"`
	VoidT2 FissureModifiersVoidT1 `json:"VoidT2"`
	VoidT3 FissureModifiersVoidT1 `json:"VoidT3"`
	VoidT4 FissureModifiersVoidT1 `json:"VoidT4"`
}

// FissureModifiersVoidT1 defines model for fissureModifiers_VoidT1.
type FissureModifiersVoidT1 struct {
	Num   float32 `json:"num"`
	Value string  `json:"value"`
}

// FissureTier defines model for fissureTier.
type FissureTier string

// Fissures defines model for fissures.
type Fissures = []FissuresInner

// FissuresInner defines model for fissures_inner.
type FissuresInner struct {
	// Activation ISO-8601 formatted timestamp for when the event began
	Activation time.Time `json:"activation"`

	// Active Whether the event is currently active
	Active   *bool                  `json:"active,omitempty"`
	Enemy    FissuresInnerEnemy     `json:"enemy"`
	EnemyKey *FissuresInnerEnemyKey `json:"enemyKey,omitempty"`

	// Eta Short-formatted string estimating the time until the event/mission is closed
	Eta string `json:"eta"`

	// Expired Whether the fissure is still present
	Expired bool `json:"expired"`

	// Expiry ISO-8601 formatted timestamp for when the event is expected to end
	Expiry time.Time `json:"expiry"`

	// Id unique identifier for this object/event/thing
	Id string `json:"id"`

	// IsHard Whether this fissure is on the Steel Path
	IsHard *bool `json:"isHard,omitempty"`

	// IsStorm Whether this fissure is a void storm
	IsStorm     *bool                    `json:"isStorm,omitempty"`
	MissionKey  *FissuresInnerMissionKey `json:"missionKey,omitempty"`
	MissionType FissuresInnerMissionType `json:"missionType"`

	// Node Node name with planet
	Node string `json:"node"`

	// StartString Short-time-formatted duration string representing the start of the event
	StartString *string     `json:"startString,omitempty"`
	Tier        interface{} `json:"tier"`

	// TierNum Numeric tier corresponding to the tier
	TierNum float32 `json:"tierNum"`
}

// FissuresInnerEnemy defines model for FissuresInner.Enemy.
type FissuresInnerEnemy string

// FissuresInnerEnemyKey defines model for FissuresInner.EnemyKey.
type FissuresInnerEnemyKey string

// FissuresInnerMissionKey defines model for FissuresInner.MissionKey.
type FissuresInnerMissionKey string

// FissuresInnerMissionType defines model for FissuresInner.MissionType.
type FissuresInnerMissionType string

// FlashSales defines model for flashSales.
type FlashSales = []struct {
	Discount        float32 `json:"discount"`
	Eta             string  `json:"eta"`
	Expired         *bool   `json:"expired,omitempty"`
	IsFeatured      bool    `json:"isFeatured"`
	IsPopular       bool    `json:"isPopular"`
	Item            string  `json:"item"`
	PremiumOverride float32 `json:"premiumOverride"`
}

// GetOutpostsByPlatform200Response defines model for getOutpostsByPlatform_200_response.
type GetOutpostsByPlatform200Response struct {
	// Activation When the mission became or becomes active
	Activation *time.Time `json:"activation,omitempty"`

	// Active Whether the outpost is active
	Active *bool `json:"active,omitempty"`

	// Expiry When the mission became or becomes inactive
	Expiry *time.Time `json:"expiry,omitempty"`

	// Id Identifier for the mission node with active indicator
	Id      *string  `json:"id,omitempty"`
	Mission *Mission `json:"mission,omitempty"`

	// Previous Estimation data for the last mission that was active. Could also be the current.
	Previous *GetOutpostsByPlatform200ResponsePrevious `json:"previous,omitempty"`
}

// GetOutpostsByPlatform200ResponsePrevious Estimation data for the last mission that was active. Could also be the current.
type GetOutpostsByPlatform200ResponsePrevious struct {
	// Activation When the mission became or becomes active
	Activation *time.Time `json:"activation,omitempty"`

	// Expiry When the mission became or becomes inactive
	Expiry *time.Time `json:"expiry,omitempty"`
}

// GetWorldstateByPlatform400Response defines model for getWorldstateByPlatform_400_response.
type GetWorldstateByPlatform400Response struct {
	// Code HTTP status code associated with error
	Code *int `json:"code,omitempty"`

	// Error Description of error
	Error *string `json:"error,omitempty"`
}

// GetWorldstateByPlatform404Response defines model for getWorldstateByPlatform_404_response.
type GetWorldstateByPlatform404Response struct {
	// Code HTTP status code associated with error
	Code *int `json:"code,omitempty"`

	// Error Description of error
	Error *string `json:"error,omitempty"`
}

// GlobalUpgrades defines model for globalUpgrades.
type GlobalUpgrades = []GlobalUpgradesInner

// GlobalUpgradesInner defines model for globalUpgrades_inner.
type GlobalUpgradesInner struct {
	// Desc Plain text description of the global upgrade.
	Desc *string `json:"desc,omitempty"`
	End  *string `json:"end,omitempty"`

	// Eta Formatted short string designating when the upgrade will expire.
	Eta *string `json:"eta,omitempty"`

	// Expired Whether the upgrade has expired
	Expired *bool `json:"expired,omitempty"`

	// Operation Operation descriptor
	Operation *string `json:"operation,omitempty"`

	// OperationSymbol Symbol corresponding to operation
	OperationSymbol *string `json:"operationSymbol,omitempty"`
	Start           *string `json:"start,omitempty"`
	Upgrade         *string `json:"upgrade,omitempty"`

	// UpgradeOperationValue Value corresponding to performing the operation
	UpgradeOperationValue *float32 `json:"upgradeOperationValue,omitempty"`
}

// Introduced defines model for introduced.
type Introduced struct {
	Aliases *[]string          `json:"aliases,omitempty"`
	Date    *openapitypes.Date `json:"date,omitempty"`
	Name    *string            `json:"name,omitempty"`
	Parent  *string            `json:"parent,omitempty"`
	Url     *string            `json:"url,omitempty"`
}

// Invasion defines model for invasion.
type Invasion struct {
	// Activation ISO-8601 formatted timestamp for when the event began
	Activation time.Time `json:"activation"`

	// Active Whether the event is currently active
	Active         *bool                        `json:"active,omitempty"`
	Attacker       *InvasionAllOfAttacker       `json:"attacker,omitempty"`
	AttackerReward *InvasionAllOfAttackerReward `json:"attackerReward,omitempty"`
	// Deprecated:
	AttackingFaction string `json:"attackingFaction"`

	// Completed Whether this invasion is "over"
	Completed bool `json:"completed"`

	// Completion percentage complete as a float value
	Completion float32 `json:"completion"`

	// Count How many fights have happened.
	Count          float32                      `json:"count"`
	Defender       *InvasionAllOfDefender       `json:"defender,omitempty"`
	DefenderReward *InvasionAllOfDefenderReward `json:"defenderReward,omitempty"`
	// Deprecated:
	DefendingFaction string `json:"defendingFaction"`

	// Desc description of invasion
	Desc string `json:"desc"`

	// Eta time string showing approximate time to the end of the invasion
	Eta string `json:"eta"`

	// Expiry ISO-8601 formatted timestamp for when the event is expected to end
	Expiry *time.Time `json:"expiry,omitempty"`

	// Id unique identifier for this object/event/thing
	Id string `json:"id"`

	// Node localized Node name
	Node string `json:"node"`

	// NodeKey i18n key for matching node (always english translation)
	NodeKey *string `json:"nodeKey,omitempty"`

	// RequiredRuns How many runs of this mission are needed to qualify for the reward
	RequiredRuns  float32       `json:"requiredRuns"`
	RewardTypes   *[]RewardType `json:"rewardTypes,omitempty"`
	StartString   *string       `json:"startString,omitempty"`
	VsInfestation bool          `json:"vsInfestation"`
}

// InvasionFaction defines model for invasionFaction.
type InvasionFaction struct {
	Faction    *InvasionFactionFaction    `json:"faction,omitempty"`
	FactionKey *InvasionFactionFactionKey `json:"factionKey,omitempty"`
	Reward     *Reward                    `json:"reward,omitempty"`
}

// InvasionFactionFaction defines model for InvasionFaction.Faction.
type InvasionFactionFaction string

// InvasionFactionFactionKey defines model for InvasionFaction.FactionKey.
type InvasionFactionFactionKey string

// InvasionAllOfAttacker defines model for invasion_allOf_attacker.
type InvasionAllOfAttacker struct {
	Faction    *InvasionAllOfAttackerFaction    `json:"faction,omitempty"`
	FactionKey *InvasionAllOfAttackerFactionKey `json:"factionKey,omitempty"`
	Reward     *Reward                          `json:"reward,omitempty"`
}

// InvasionAllOfAttackerFaction defines model for InvasionAllOfAttacker.Faction.
type InvasionAllOfAttackerFaction string

// InvasionAllOfAttackerFactionKey defines model for InvasionAllOfAttacker.FactionKey.
type InvasionAllOfAttackerFactionKey string

// InvasionAllOfAttackerReward defines model for invasion_allOf_attackerReward.
type InvasionAllOfAttackerReward struct {
	// AsString string representation of the reward
	AsString string `json:"asString"`

	// Color RGB value as an int assigned to this reward
	Color float32 `json:"color"`

	// CountedItems Items that have a quantity attached
	CountedItems []RewardCountedItemsInner `json:"countedItems"`

	// Credits Amount of credits awarded
	Credits int32 `json:"credits"`

	// ItemString formatted string describing all included items
	ItemString string `json:"itemString"`

	// Items Items' names possible to be won
	Items []string `json:"items"`

	// Thumbnail thumbnail URL
	Thumbnail string `json:"thumbnail"`
}

// InvasionAllOfDefender defines model for invasion_allOf_defender.
type InvasionAllOfDefender struct {
	Faction    *InvasionAllOfDefenderFaction    `json:"faction,omitempty"`
	FactionKey *InvasionAllOfDefenderFactionKey `json:"factionKey,omitempty"`
	Reward     *Reward                          `json:"reward,omitempty"`
}

// InvasionAllOfDefenderFaction defines model for InvasionAllOfDefender.Faction.
type InvasionAllOfDefenderFaction string

// InvasionAllOfDefenderFactionKey defines model for InvasionAllOfDefender.FactionKey.
type InvasionAllOfDefenderFactionKey string

// InvasionAllOfDefenderReward defines model for invasion_allOf_defenderReward.
type InvasionAllOfDefenderReward struct {
	// AsString string representation of the reward
	AsString string `json:"asString"`

	// Color RGB value as an int assigned to this reward
	Color float32 `json:"color"`

	// CountedItems Items that have a quantity attached
	CountedItems []RewardCountedItemsInner `json:"countedItems"`

	// Credits Amount of credits awarded
	Credits int32 `json:"credits"`

	// ItemString formatted string describing all included items
	ItemString string `json:"itemString"`

	// Items Items' names possible to be won
	Items []string `json:"items"`

	// Thumbnail thumbnail URL
	Thumbnail string `json:"thumbnail"`
}

// Invasions defines model for invasions.
type Invasions = []Invasion

// Item defines model for item.
type Item struct {
	Category           *string            `json:"category,omitempty"`
	Components         *[]ShallowItem     `json:"components,omitempty"`
	Description        *string            `json:"description,omitempty"`
	EstimatedVaultDate *openapitypes.Date `json:"estimatedVaultDate,omitempty"`
	Introduced         *Introduced        `json:"introduced,omitempty"`
	Name               *string            `json:"name,omitempty"`
	Patchlogs          *[]Patchlog        `json:"patchlogs,omitempty"`
	ProductCategory    *string            `json:"productCategory,omitempty"`
	Tradable           *bool              `json:"tradable,omitempty"`
	Type               *string            `json:"type,omitempty"`
	UniqueName         *string            `json:"uniqueName,omitempty"`
}

// Items An item from Warframe
type Items = []ItemsInner

// ItemsInner defines model for items_inner.
type ItemsInner struct {
	union json.RawMessage
}

// Language defines model for language.
type Language string

// Languages defines model for languages.
type Languages struct {
	LanguageKey *ConclaveModesPVPMODEALL `json:"languageKey,omitempty"`
}

// MeleeWeapon defines model for meleeWeapon.
type MeleeWeapon struct {
	Attacks               *[]Attack          `json:"attacks,omitempty"`
	BlockingAngle         *int               `json:"blockingAngle,omitempty"`
	BpCost                *string            `json:"bpCost,omitempty"`
	BuildPrice            *int               `json:"buildPrice,omitempty"`
	BuildQuantity         *int               `json:"buildQuantity,omitempty"`
	BuildTime             *int               `json:"buildTime,omitempty"`
	Category              *string            `json:"category,omitempty"`
	ComboDuration         *int               `json:"comboDuration,omitempty"`
	Components            *[]ShallowItem     `json:"components,omitempty"`
	ConsumeOnBuild        *bool              `json:"consumeOnBuild,omitempty"`
	CriticalChance        *float32           `json:"criticalChance,omitempty"`
	CriticalMultiplier    *float32           `json:"criticalMultiplier,omitempty"`
	DamagePerShot         *[]float32         `json:"damagePerShot,omitempty"`
	Description           *string            `json:"description,omitempty"`
	Disposition           *int               `json:"disposition,omitempty"`
	EstimatedVaultDate    *openapitypes.Date `json:"estimatedVaultDate,omitempty"`
	FireRate              *float32           `json:"fireRate,omitempty"`
	FollowThrough         *float32           `json:"followThrough,omitempty"`
	HeavyAttackDamage     *int               `json:"heavyAttackDamage,omitempty"`
	HeavySlamAttack       *int               `json:"heavySlamAttack,omitempty"`
	HeavySlamRadialDamage *int               `json:"heavySlamRadialDamage,omitempty"`
	HeavySlamRadius       *int               `json:"heavySlamRadius,omitempty"`
	Introduced            *Introduced        `json:"introduced,omitempty"`
	MarketCost            *string            `json:"marketCost,omitempty"`
	MasteryReq            *int               `json:"masteryReq,omitempty"`
	Mr                    *float32           `json:"mr,omitempty"`
	Name                  *string            `json:"name,omitempty"`
	OmegaAttenuation      *float32           `json:"omegaAttenuation,omitempty"`
	Patchlogs             *[]Patchlog        `json:"patchlogs,omitempty"`
	Polarities            *[]Polarity        `json:"polarities,omitempty"`
	ProcChance            *float32           `json:"procChance,omitempty"`
	ProductCategory       *string            `json:"productCategory,omitempty"`
	Range                 *float32           `json:"range,omitempty"`
	ReleaseDate           *float32           `json:"releaseDate,omitempty"`
	RivenDisposition      *float32           `json:"riven_disposition,omitempty"`
	SkipBuildTimePrice    *int               `json:"skipBuildTimePrice,omitempty"`
	SlamAttack            *int               `json:"slamAttack,omitempty"`
	SlamRadialDamage      *int               `json:"slamRadialDamage,omitempty"`
	SlamRadius            *int               `json:"slamRadius,omitempty"`
	SlideAttack           *int               `json:"slideAttack,omitempty"`

	// Slot Specifies the slot of an item.
	Slot           *int               `json:"slot,omitempty"`
	StancePolarity *Polarity          `json:"stancePolarity,omitempty"`
	Tags           *[]string          `json:"tags,omitempty"`
	Thumbnail      *string            `json:"thumbnail,omitempty"`
	TotalDamage    *int               `json:"totalDamage,omitempty"`
	Tradable       *bool              `json:"tradable,omitempty"`
	Type           *string            `json:"type,omitempty"`
	UniqueName     *string            `json:"uniqueName,omitempty"`
	Url            *string            `json:"url,omitempty"`
	VaultDate      *openapitypes.Date `json:"vaultDate,omitempty"`
	Vaulted        *bool              `json:"vaulted,omitempty"`
	WikiaThumbnail *string            `json:"wikiaThumbnail,omitempty"`
	WikiaUrl       *string            `json:"wikiaUrl,omitempty"`
	WindUp         *float32           `json:"windUp,omitempty"`
}

// Mission defines model for mission.
type Mission struct {
	// AdvancedSpawners Array of strings denoting extra spawners for a mission
	AdvancedSpawners *[]string `json:"advancedSpawners,omitempty"`

	// ArchwingRequired Whether an Archwing is required for participating in the mision.
	ArchwingRequired bool `json:"archwingRequired"`

	// ConsumeRequiredItems Whether the required items are consumed
	ConsumeRequiredItems *bool `json:"consumeRequiredItems,omitempty"`

	// Description Description of the mission
	Description string `json:"description"`

	// EnemySpec Enemy specification for the mission
	EnemySpec  *string            `json:"enemySpec,omitempty"`
	Faction    MissionFaction     `json:"faction"`
	FactionKey *MissionFactionKey `json:"factionKey,omitempty"`

	// IsSharkwing Whether the mission takes place in a submerssible mission.
	IsSharkwing *bool `json:"isSharkwing,omitempty"`

	// LeadersAlwaysAllowed Whether leaders are always allowed
	LeadersAlwaysAllowed *bool `json:"leadersAlwaysAllowed,omitempty"`

	// LevelAuras Affectors for this mission
	LevelAuras *[]string `json:"levelAuras,omitempty"`

	// LevelOverride Override for the map on this mission
	LevelOverride *string `json:"levelOverride,omitempty"`
	MaxEnemyLevel float32 `json:"maxEnemyLevel"`
	MaxWaveNum    float32 `json:"maxWaveNum"`
	MinEnemyLevel float32 `json:"minEnemyLevel"`
	Nightmare     bool    `json:"nightmare"`
	Node          string  `json:"node"`

	// NodeKey Unlocalized node
	NodeKey *string `json:"nodeKey,omitempty"`

	// RequiredItems Items required to enter the mission
	RequiredItems *[]string       `json:"requiredItems,omitempty"`
	Reward        Reward          `json:"reward"`
	Type          MissionType     `json:"type"`
	TypeKey       *MissionTypeKey `json:"typeKey,omitempty"`
}

// MissionFaction defines model for Mission.Faction.
type MissionFaction string

// MissionFactionKey defines model for Mission.FactionKey.
type MissionFactionKey string

// MissionType defines model for Mission.Type.
type MissionType string

// MissionTypeKey defines model for Mission.TypeKey.
type MissionTypeKey string

// MissionCategory A Warframe mision type, the kind of game mode that the mission/node houses.
type MissionCategory string

// MissionTypes defines model for missionTypes.
type MissionTypes struct {
	MTARENA         ConclaveModesPVPMODEALL `json:"MT_ARENA"`
	MTASSASSINATION ConclaveModesPVPMODEALL `json:"MT_ASSASSINATION"`
	MTASSAULT       ConclaveModesPVPMODEALL `json:"MT_ASSAULT"`
	MTCAPTURE       ConclaveModesPVPMODEALL `json:"MT_CAPTURE"`
	MTDEFENSE       ConclaveModesPVPMODEALL `json:"MT_DEFENSE"`
	MTEVACUATION    ConclaveModesPVPMODEALL `json:"MT_EVACUATION"`
	MTEXCAVATE      ConclaveModesPVPMODEALL `json:"MT_EXCAVATE"`
	MTEXTERMINATION ConclaveModesPVPMODEALL `json:"MT_EXTERMINATION"`
	MTHIVE          ConclaveModesPVPMODEALL `json:"MT_HIVE"`
	MTINTEL         ConclaveModesPVPMODEALL `json:"MT_INTEL"`
	MTMOBILEDEFENSE ConclaveModesPVPMODEALL `json:"MT_MOBILE_DEFENSE"`
	MTPVP           ConclaveModesPVPMODEALL `json:"MT_PVP"`
	MTRESCUE        ConclaveModesPVPMODEALL `json:"MT_RESCUE"`
	MTRETRIEVAL     ConclaveModesPVPMODEALL `json:"MT_RETRIEVAL"`
	MTSABOTAGE      ConclaveModesPVPMODEALL `json:"MT_SABOTAGE"`
	MTSECTOR        ConclaveModesPVPMODEALL `json:"MT_SECTOR"`
	MTSURVIVAL      ConclaveModesPVPMODEALL `json:"MT_SURVIVAL"`
	MTTERRITORY     ConclaveModesPVPMODEALL `json:"MT_TERRITORY"`
}

// Mod defines model for mod.
type Mod struct {
	BaseDrain          *int                  `json:"baseDrain,omitempty"`
	Category           *string               `json:"category,omitempty"`
	CompatName         *string               `json:"compatName,omitempty"`
	Components         *[]ShallowItem        `json:"components,omitempty"`
	Description        *string               `json:"description,omitempty"`
	EstimatedVaultDate *openapitypes.Date    `json:"estimatedVaultDate,omitempty"`
	FusionLimit        *int                  `json:"fusionLimit,omitempty"`
	Introduced         *Introduced           `json:"introduced,omitempty"`
	LevelStats         *[]ModAllOfLevelStats `json:"levelStats,omitempty"`
	Name               *string               `json:"name,omitempty"`
	Patchlogs          *[]Patchlog           `json:"patchlogs,omitempty"`
	Polarity           *Polarity             `json:"polarity,omitempty"`
	ProductCategory    *string               `json:"productCategory,omitempty"`
	Tradable           *bool                 `json:"tradable,omitempty"`
	Transmutable       *bool                 `json:"transmutable,omitempty"`
	Type               *string               `json:"type,omitempty"`
	UniqueName         *string               `json:"uniqueName,omitempty"`
}

// ModAllOfLevelStats defines model for mod_allOf_levelStats.
type ModAllOfLevelStats struct {
	Stats *[]string `json:"stats,omitempty"`
}

// News defines model for news.
type News = []NewsInner

// NewsInner defines model for news_inner.
type NewsInner struct {
	AsString     string                 `json:"asString"`
	Date         string                 `json:"date"`
	Eta          string                 `json:"eta"`
	Id           string                 `json:"id"`
	ImageLink    string                 `json:"imageLink"`
	Link         string                 `json:"link"`
	Message      string                 `json:"message"`
	PrimeAccess  bool                   `json:"primeAccess"`
	Priority     bool                   `json:"priority"`
	Stream       bool                   `json:"stream"`
	Translations *NewsInnerTranslations `json:"translations,omitempty"`
	Update       bool                   `json:"update"`
}

// NewsInnerTranslations defines model for news_inner_translations.
type NewsInnerTranslations struct {
	Es string `json:"es"`
}

// Nightwave defines model for nightwave.
type Nightwave struct {
	// Activation ISO-8601 formatted timestamp for when the event began
	Activation *time.Time `json:"activation,omitempty"`

	// Active Whether the event is currently active
	Active           *bool                 `json:"active,omitempty"`
	ActiveChallenges *[]NightwaveChallenge `json:"activeChallenges,omitempty"`

	// Expiry ISO-8601 formatted timestamp for when the event is expected to end
	Expiry *time.Time `json:"expiry,omitempty"`

	// Id unique identifier for this object/event/thing
	Id                 *string               `json:"id,omitempty"`
	Params             *NightwaveAllOfParams `json:"params,omitempty"`
	Phase              *float32              `json:"phase,omitempty"`
	PossibleChallenges *[]NightwaveChallenge `json:"possibleChallenges,omitempty"`
	RewardTypes        *[]string             `json:"rewardTypes,omitempty"`
	Season             *float32              `json:"season,omitempty"`

	// StartString Short-time-formatted duration string representing the start of the event
	StartString *string `json:"startString,omitempty"`
	Tag         *string `json:"tag,omitempty"`
}

// NightwaveChallenge defines model for nightwaveChallenge.
type NightwaveChallenge struct {
	// Activation ISO-8601 formatted timestamp for when the event began
	Activation *time.Time `json:"activation,omitempty"`

	// Active Whether the event is currently active
	Active *bool   `json:"active,omitempty"`
	Desc   *string `json:"desc,omitempty"`

	// Expiry ISO-8601 formatted timestamp for when the event is expected to end
	Expiry *time.Time `json:"expiry,omitempty"`

	// Id unique identifier for this object/event/thing
	Id         *string  `json:"id,omitempty"`
	IsDaily    *bool    `json:"isDaily,omitempty"`
	IsElite    *bool    `json:"isElite,omitempty"`
	Reputation *float32 `json:"reputation,omitempty"`

	// StartString Short-time-formatted duration string representing the start of the event
	StartString *string `json:"startString,omitempty"`
	Title       *string `json:"title,omitempty"`
}

// NightwaveAllOfParams defines model for nightwave_allOf_params.
type NightwaveAllOfParams = map[string]interface{}

// OperationTypes defines model for operationTypes.
type OperationTypes struct {
	MULTIPLY ConclaveModesPVPMODEALL `json:"MULTIPLY"`
}

// Patchlog defines model for patchlog.
type Patchlog struct {
	Additions *string    `json:"additions,omitempty"`
	Changes   *string    `json:"changes,omitempty"`
	Date      *time.Time `json:"date,omitempty"`
	Fixes     *string    `json:"fixes,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Url       *string    `json:"url,omitempty"`
}

// PersistentEnemies defines model for persistentEnemies.
type PersistentEnemies = []PersistentEnemiesInner

// PersistentEnemiesInner defines model for persistentEnemies_inner.
type PersistentEnemiesInner struct {
	// AgentType Which acolyte it is
	AgentType *string `json:"agentType,omitempty"`

	// FleeDamage The percent damage that the enemy takes when it's defeated
	FleeDamage *float32 `json:"fleeDamage,omitempty"`

	// HealthPercent Enemy's remaining health
	HealthPercent *float32 `json:"healthPercent,omitempty"`

	// IsDiscovered Whether the enemy is currently discovered
	IsDiscovered *bool `json:"isDiscovered,omitempty"`

	// IsUsingTicketing Whether the enemy is using 'ticketing'. Unknown usage.
	IsUsingTicketing *bool `json:"isUsingTicketing,omitempty"`

	// LastDiscoveredAt Node at which the enemy was last discovered
	LastDiscoveredAt *string `json:"lastDiscoveredAt,omitempty"`

	// LastDiscoveredTime The time at which the enemy was last discovered
	LastDiscoveredTime *string `json:"lastDiscoveredTime,omitempty"`

	// LocationTag Location tag for Acolyte
	LocationTag *string `json:"locationTag,omitempty"`

	// Pid faux-id incorporating the actual description and Whether the enemy is discovered.
	Pid *string `json:"pid,omitempty"`

	// Rank Enemy level
	Rank *float32 `json:"rank,omitempty"`

	// Region The region in which the enemy is located
	Region *string `json:"region,omitempty"`
}

// Platform defines model for platform.
type Platform string

// Polarity defines model for polarity.
type Polarity string

// RangedWeapon defines model for rangedWeapon.
type RangedWeapon struct {
	Accuracy           *float32           `json:"accuracy,omitempty"`
	Ammo               *float32           `json:"ammo,omitempty"`
	Attacks            *[]Attack          `json:"attacks,omitempty"`
	BpCost             *string            `json:"bpCost,omitempty"`
	BuildPrice         *int               `json:"buildPrice,omitempty"`
	BuildQuantity      *int               `json:"buildQuantity,omitempty"`
	BuildTime          *int               `json:"buildTime,omitempty"`
	Category           *string            `json:"category,omitempty"`
	Components         *[]ShallowItem     `json:"components,omitempty"`
	ConsumeOnBuild     *bool              `json:"consumeOnBuild,omitempty"`
	CriticalChance     *float32           `json:"criticalChance,omitempty"`
	CriticalMultiplier *float32           `json:"criticalMultiplier,omitempty"`
	Description        *string            `json:"description,omitempty"`
	Disposition        *int               `json:"disposition,omitempty"`
	EstimatedVaultDate *openapitypes.Date `json:"estimatedVaultDate,omitempty"`
	FireRate           *float32           `json:"fireRate,omitempty"`
	Introduced         *Introduced        `json:"introduced,omitempty"`
	MagazineSize       *int               `json:"magazineSize,omitempty"`
	MarketCost         *string            `json:"marketCost,omitempty"`
	MasteryReq         *int               `json:"masteryReq,omitempty"`
	Mr                 *float32           `json:"mr,omitempty"`
	Multishot          *float32           `json:"multishot,omitempty"`
	Name               *string            `json:"name,omitempty"`
	Noise              *string            `json:"noise,omitempty"`
	OmegaAttenuation   *float32           `json:"omegaAttenuation,omitempty"`
	Patchlogs          *[]Patchlog        `json:"patchlogs,omitempty"`
	Polarities         *[]Polarity        `json:"polarities,omitempty"`
	ProcChance         *float32           `json:"procChance,omitempty"`
	ProductCategory    *string            `json:"productCategory,omitempty"`
	ReleaseDate        *float32           `json:"releaseDate,omitempty"`
	RivenDisposition   *float32           `json:"riven_disposition,omitempty"`
	SkipBuildTimePrice *int               `json:"skipBuildTimePrice,omitempty"`

	// Slot Specifies the slot of an item.
	Slot           *int               `json:"slot,omitempty"`
	Tags           *[]string          `json:"tags,omitempty"`
	Thumbnail      *string            `json:"thumbnail,omitempty"`
	TotalDamage    *int               `json:"totalDamage,omitempty"`
	Tradable       *bool              `json:"tradable,omitempty"`
	Trigger        *string            `json:"trigger,omitempty"`
	Type           *string            `json:"type,omitempty"`
	UniqueName     *string            `json:"uniqueName,omitempty"`
	Url            *string            `json:"url,omitempty"`
	VaultDate      *openapitypes.Date `json:"vaultDate,omitempty"`
	Vaulted        *bool              `json:"vaulted,omitempty"`
	WikiaThumbnail *string            `json:"wikiaThumbnail,omitempty"`
	WikiaUrl       *string            `json:"wikiaUrl,omitempty"`
}

// Reward defines model for reward.
type Reward struct {
	// AsString string representation of the reward
	AsString string `json:"asString"`

	// Color RGB value as an int assigned to this reward
	Color float32 `json:"color"`

	// CountedItems Items that have a quantity attached
	CountedItems []RewardCountedItemsInner `json:"countedItems"`

	// Credits Amount of credits awarded
	Credits int32 `json:"credits"`

	// ItemString formatted string describing all included items
	ItemString string `json:"itemString"`

	// Items Items' names possible to be won
	Items []string `json:"items"`

	// Thumbnail thumbnail URL
	Thumbnail string `json:"thumbnail"`
}

// RewardType One of the reward types
type RewardType string

// RewardCountedItemsInner defines model for reward_countedItems_inner.
type RewardCountedItemsInner struct {
	Count float32 `json:"count"`
	Type  string  `json:"type"`
}

// Riven defines model for riven.
type Riven struct {
	// RivenCompatability The name of the weapon that this riven is compatible with
	RivenCompatability *map[string]RivenRivenCompatabilityValue `json:"rivenCompatability,omitempty"`
}

// RivenStatistic A colleciton of rivens about a specific weapon's riven sales
type RivenStatistic struct {
	Avg           *float32 `json:"avg,omitempty"`
	Compatability *string  `json:"compatability,omitempty"`
	ItemType      *string  `json:"itemType,omitempty"`
	Max           *float32 `json:"max,omitempty"`
	Median        *float32 `json:"median,omitempty"`
	Min           *float32 `json:"min,omitempty"`
	Pop           *float32 `json:"pop,omitempty"`
	Rerolled      *bool    `json:"rerolled,omitempty"`
	Stddev        *float32 `json:"stddev,omitempty"`
}

// RivenType The type of riven that the child rivens belong to
type RivenType map[string]Riven

// RivenRivenCompatabilityValue defines model for riven_rivenCompatability_value.
type RivenRivenCompatabilityValue struct {
	// Rolled A colleciton of rivens about a specific weapon's riven sales
	Rolled *RivenStatistic `json:"rolled,omitempty"`

	// Unrolled A colleciton of rivens about a specific weapon's riven sales
	Unrolled *RivenStatistic `json:"unrolled,omitempty"`
}

// SearchAcolytesData200ResponseInner defines model for searchAcolytesData_200_response_inner.
type SearchAcolytesData200ResponseInner struct {
	union json.RawMessage
}

// SearchAcolytesData200ResponseInner0 defines model for .
type SearchAcolytesData200ResponseInner0 = []string

// ShallowItem defines model for shallowItem.
type ShallowItem struct {
	Category        *string `json:"category,omitempty"`
	Description     *string `json:"description,omitempty"`
	Name            *string `json:"name,omitempty"`
	ProductCategory *string `json:"productCategory,omitempty"`
	Tradable        *bool   `json:"tradable,omitempty"`
	Type            *string `json:"type,omitempty"`
	UniqueName      *string `json:"uniqueName,omitempty"`
}

// Simaris defines model for simaris.
type Simaris struct {
	AsString       string `json:"asString"`
	IsTargetActive bool   `json:"isTargetActive"`
	Target         string `json:"target"`
}

// SimpleReward defines model for simpleReward.
type SimpleReward struct {
	// Cost Resource cost of item
	Cost *float32 `json:"cost,omitempty"`

	// Name Name of current reward
	Name *string `json:"name,omitempty"`
}

// SlamAttack defines model for slamAttack.
type SlamAttack struct {
	Damage *float32          `json:"damage,omitempty"`
	Radial *SlamAttackRadial `json:"radial,omitempty"`
}

// SlamAttackRadial defines model for slamAttack_radial.
type SlamAttackRadial struct {
	Damage  *float32 `json:"damage,omitempty"`
	Element *Element `json:"element,omitempty"`
	Proc    *float32 `json:"proc,omitempty"`
	Radius  *float32 `json:"radius,omitempty"`
}

// SolNode defines model for solNode.
type SolNode struct {
	SolKey *SolNodeSolKey `json:"SolKey,omitempty"`
}

// SolNodeSearch defines model for solNodeSearch.
type SolNodeSearch = []SolNodeSearchInner

// SolNodeSearchInner defines model for solNodeSearch_inner.
type SolNodeSearchInner struct {
	Keys  []string        `json:"keys"`
	Nodes []SolNodeSolKey `json:"nodes"`
}

// SolNodeSolKey defines model for solNode_SolKey.
type SolNodeSolKey struct {
	Enemy string `json:"enemy"`
	Type  string `json:"type"`
	Value string `json:"value"`
}

// Sortie defines model for sortie.
type Sortie struct {
	// Activation ISO-8601 formatted timestamp for when the event began
	Activation time.Time `json:"activation"`

	// Active Whether the event is currently active
	Active  *bool  `json:"active,omitempty"`
	Boss    string `json:"boss"`
	Eta     string `json:"eta"`
	Expired bool   `json:"expired"`

	// Expiry ISO-8601 formatted timestamp for when the event is expected to end
	Expiry     time.Time              `json:"expiry"`
	Faction    SortieAllOfFaction     `json:"faction"`
	FactionKey *SortieAllOfFactionKey `json:"factionKey,omitempty"`

	// Id unique identifier for this object/event/thing
	Id         string `json:"id"`
	RewardPool string `json:"rewardPool"`

	// StartString Short-time-formatted duration string representing the start of the event
	StartString *string               `json:"startString,omitempty"`
	Variants    []SortieAllOfVariants `json:"variants"`
}

// SortieData defines model for sortieData.
type SortieData struct {
	Bosses               SortieDataBosses           `json:"bosses"`
	EndStates            []SortieDataEndStatesInner `json:"endStates"`
	ModifierDescriptions SortieDataModifierTypes    `json:"modifierDescriptions"`
	ModifierTypes        SortieDataModifierTypes    `json:"modifierTypes"`
	Modifiers            []string                   `json:"modifiers"`
}

// SortieDataBosses defines model for sortieData_bosses.
type SortieDataBosses struct {
	SORTIEBOSSALAD         SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_ALAD"`
	SORTIEBOSSAMBULAS      SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_AMBULAS"`
	SORTIEBOSSCORRUPTEDVOR SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_CORRUPTED_VOR"`
	SORTIEBOSSHEK          SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_HEK"`
	SORTIEBOSSHYENA        SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_HYENA"`
	SORTIEBOSSINFALAD      SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_INFALAD"`
	SORTIEBOSSJACKAL       SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_JACKAL"`
	SORTIEBOSSKELA         SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_KELA"`
	SORTIEBOSSKRIL         SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_KRIL"`
	SORTIEBOSSLEPHANTIS    SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_LEPHANTIS"`
	SORTIEBOSSNEF          SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_NEF"`
	SORTIEBOSSPHORID       SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_PHORID"`
	SORTIEBOSSRAPTOR       SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_RAPTOR"`
	SORTIEBOSSRUK          SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_RUK"`
	SORTIEBOSSTYL          SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_TYL"`
	SORTIEBOSSVOR          SortieDataBossesSORTIEBOSSKELA `json:"SORTIE_BOSS_VOR"`
}

// SortieDataBossesSORTIEBOSSKELA defines model for sortieData_bosses_SORTIE_BOSS_KELA.
type SortieDataBossesSORTIEBOSSKELA struct {
	Faction string `json:"faction"`
	Name    string `json:"name"`
}

// SortieDataEndStatesInner defines model for sortieData_endStates_inner.
type SortieDataEndStatesInner struct {
	BossName string                                  `json:"bossName"`
	Regions  *[]SortieDataEndStatesInnerRegionsInner `json:"regions,omitempty"`
}

// SortieDataEndStatesInnerRegionsInner defines model for sortieData_endStates_inner_regions_inner.
type SortieDataEndStatesInnerRegionsInner struct {
	Missions *[]string `json:"missions,omitempty"`
	Name     string    `json:"name"`
}

// SortieDataModifierTypes defines model for sortieData_modifierTypes.
type SortieDataModifierTypes struct {
	SORTIEMODIFIERARMOR           string `json:"SORTIE_MODIFIER_ARMOR"`
	SORTIEMODIFIERBOWONLY         string `json:"SORTIE_MODIFIER_BOW_ONLY"`
	SORTIEMODIFIERCORROSIVE       string `json:"SORTIE_MODIFIER_CORROSIVE"`
	SORTIEMODIFIERELECTRICITY     string `json:"SORTIE_MODIFIER_ELECTRICITY"`
	SORTIEMODIFIEREXIMUS          string `json:"SORTIE_MODIFIER_EXIMUS"`
	SORTIEMODIFIEREXPLOSION       string `json:"SORTIE_MODIFIER_EXPLOSION"`
	SORTIEMODIFIERFIRE            string `json:"SORTIE_MODIFIER_FIRE"`
	SORTIEMODIFIERFREEZE          string `json:"SORTIE_MODIFIER_FREEZE"`
	SORTIEMODIFIERGAS             string `json:"SORTIE_MODIFIER_GAS"`
	SORTIEMODIFIERHAZARDCOLD      string `json:"SORTIE_MODIFIER_HAZARD_COLD"`
	SORTIEMODIFIERHAZARDFIRE      string `json:"SORTIE_MODIFIER_HAZARD_FIRE"`
	SORTIEMODIFIERHAZARDFOG       string `json:"SORTIE_MODIFIER_HAZARD_FOG"`
	SORTIEMODIFIERHAZARDICE       string `json:"SORTIE_MODIFIER_HAZARD_ICE"`
	SORTIEMODIFIERHAZARDMAGNETIC  string `json:"SORTIE_MODIFIER_HAZARD_MAGNETIC"`
	SORTIEMODIFIERHAZARDRADIATION string `json:"SORTIE_MODIFIER_HAZARD_RADIATION"`
	SORTIEMODIFIERIMPACT          string `json:"SORTIE_MODIFIER_IMPACT"`
	SORTIEMODIFIERLOWENERGY       string `json:"SORTIE_MODIFIER_LOW_ENERGY"`
	SORTIEMODIFIERMAGNETIC        string `json:"SORTIE_MODIFIER_MAGNETIC"`
	SORTIEMODIFIERMELEEONLY       string `json:"SORTIE_MODIFIER_MELEE_ONLY"`
	SORTIEMODIFIERPOISON          string `json:"SORTIE_MODIFIER_POISON"`
	SORTIEMODIFIERPUNCTURE        string `json:"SORTIE_MODIFIER_PUNCTURE"`
	SORTIEMODIFIERRADIATION       string `json:"SORTIE_MODIFIER_RADIATION"`
	SORTIEMODIFIERRIFLEONLY       string `json:"SORTIE_MODIFIER_RIFLE_ONLY"`
	SORTIEMODIFIERSECONDARYONLY   string `json:"SORTIE_MODIFIER_SECONDARY_ONLY"`
	SORTIEMODIFIERSHIELDS         string `json:"SORTIE_MODIFIER_SHIELDS"`
	SORTIEMODIFIERSHOTGUNONLY     string `json:"SORTIE_MODIFIER_SHOTGUN_ONLY"`
	SORTIEMODIFIERSLASH           string `json:"SORTIE_MODIFIER_SLASH"`
	SORTIEMODIFIERSNIPERONLY      string `json:"SORTIE_MODIFIER_SNIPER_ONLY"`
	SORTIEMODIFIERTOXIN           string `json:"SORTIE_MODIFIER_TOXIN"`
	SORTIEMODIFIERVIRAL           string `json:"SORTIE_MODIFIER_VIRAL"`
}

// SortieAllOfFaction defines model for sortie_allOf_faction.
type SortieAllOfFaction string

// SortieAllOfFactionKey defines model for sortie_allOf_factionKey.
type SortieAllOfFactionKey string

// SortieAllOfVariants defines model for sortie_allOf_variants.
type SortieAllOfVariants struct {
	Boss string `json:"boss"`

	// MissionCategory A Warframe mision type, the kind of game mode that the mission/node houses.
	MissionCategory     MissionCategory `json:"missionType"`
	Modifier            string          `json:"modifier"`
	ModifierDescription string          `json:"modifierDescription"`
	Node                string          `json:"node"`
	Planet              string          `json:"planet"`
}

// SteelPath defines model for steelPath.
type SteelPath struct {
	Activation    *time.Time        `json:"activation,omitempty"`
	CurrentReward *SimpleReward     `json:"currentReward,omitempty"`
	Evergreens    *[]SimpleReward   `json:"evergreens,omitempty"`
	Expiry        *time.Time        `json:"expiry,omitempty"`
	Incursions    *WorldstateObject `json:"incursions,omitempty"`
	Remaining     *string           `json:"remaining,omitempty"`
	Rotation      *[]SimpleReward   `json:"rotation,omitempty"`
}

// Syndicate defines model for syndicate.
type Syndicate string

// SyndicateJob A Job for a syndicate. Often called a bounty.
type SyndicateJob struct {
	// Activation Timestamp for when the job becomes active
	Activation *time.Time `json:"activation,omitempty"`

	// EnemyLevels Array of enemy levels
	EnemyLevels *[]float32 `json:"enemyLevels,omitempty"`

	// Expiry Timestamp for when the job becomes inactive
	Expiry *time.Time `json:"expiry,omitempty"`

	// MinMR Minimum Mastery Rank required to perform a job.
	MinMR *float32 `json:"minMR,omitempty"`

	// RewardPool Reward Pool for the job
	RewardPool *[]string `json:"rewardPool,omitempty"`

	// StandingStages Stages of standing rewards.
	StandingStages *[]float32 `json:"standingStages,omitempty"`

	// Type What type of Job (Bounty) it is
	Type *string `json:"type,omitempty"`
}

// SyndicateMission defines model for syndicateMission.
type SyndicateMission struct {
	Activation time.Time       `json:"activation"`
	Eta        string          `json:"eta"`
	Expiry     time.Time       `json:"expiry"`
	Id         string          `json:"id"`
	Jobs       *[]SyndicateJob `json:"jobs,omitempty"`
	Nodes      *[]string       `json:"nodes,omitempty"`
	Syndicate  Syndicate       `json:"syndicate"`
}

// SyndicateMissions defines model for syndicateMissions.
type SyndicateMissions = []SyndicateMission

// Syndicates defines model for syndicates.
type Syndicates struct {
	ArbitersSyndicate      SyndicatesArbitersSyndicate `json:"ArbitersSyndicate"`
	AssassinsSyndicate     SyndicatesArbitersSyndicate `json:"AssassinsSyndicate"`
	CephalonSudaSyndicate  SyndicatesArbitersSyndicate `json:"CephalonSudaSyndicate"`
	CetusSyndicate         SyndicatesArbitersSyndicate `json:"CetusSyndicate"`
	EventSyndicate         SyndicatesArbitersSyndicate `json:"EventSyndicate"`
	NewLokaSyndicate       SyndicatesArbitersSyndicate `json:"NewLokaSyndicate"`
	PerrinSyndicate        SyndicatesArbitersSyndicate `json:"PerrinSyndicate"`
	QuillsSyndicate        SyndicatesArbitersSyndicate `json:"QuillsSyndicate"`
	RedVeilSyndicate       SyndicatesArbitersSyndicate `json:"RedVeilSyndicate"`
	SteelMeridianSyndicate SyndicatesArbitersSyndicate `json:"SteelMeridianSyndicate"`
}

// SyndicatesArbitersSyndicate defines model for syndicates_ArbitersSyndicate.
type SyndicatesArbitersSyndicate struct {
	Name string `json:"name"`
}

// Timestamp defines model for timestamp.
type Timestamp = string

// Tutorials defines model for tutorials.
type Tutorials = []TutorialsInner

// TutorialsInner defines model for tutorials_inner.
type TutorialsInner struct {
	Name  string `json:"name"`
	Regex string `json:"regex"`
	Url   string `json:"url"`
}

// UpgradeTypes defines model for upgradeTypes.
type UpgradeTypes struct {
	GAMEPLAYKILLXPAMOUNT      ConclaveModesPVPMODEALL `json:"GAMEPLAY_KILL_XP_AMOUNT"`
	GAMEPLAYMONEYPICKUPAMOUNT ConclaveModesPVPMODEALL `json:"GAMEPLAY_MONEY_PICKUP_AMOUNT"`
	GAMEPLAYMONEYREWARDAMOUNT ConclaveModesPVPMODEALL `json:"GAMEPLAY_MONEY_REWARD_AMOUNT"`
	GAMEPLAYPICKUPAMOUNT      ConclaveModesPVPMODEALL `json:"GAMEPLAY_PICKUP_AMOUNT"`
}

// VallisCycle defines model for vallisCycle.
type VallisCycle struct {
	Expiry   string `json:"expiry"`
	Id       string `json:"id"`
	IsWarm   bool   `json:"isWarm"`
	TimeLeft string `json:"timeLeft"`
}

// VoidTrader defines model for voidTrader.
type VoidTrader struct {
	// Activation ISO-8601 formatted timestamp for when the event began
	Activation *time.Time `json:"activation,omitempty"`
	Active     bool       `json:"active"`
	Character  string     `json:"character"`
	EndString  string     `json:"endString"`

	// Expiry ISO-8601 formatted timestamp for when the event is expected to end
	Expiry *time.Time `json:"expiry,omitempty"`

	// Id unique identifier for this object/event/thing
	Id          *string                    `json:"id,omitempty"`
	Inventory   []VoidTraderAllOfInventory `json:"inventory"`
	Location    string                     `json:"location"`
	PsId        string                     `json:"psId"`
	StartString string                     `json:"startString"`
}

// VoidTraderAllOfInventory defines model for voidTrader_allOf_inventory.
type VoidTraderAllOfInventory struct {
	// Credits Amount of credits required to purchase item
	Credits *float32 `json:"credits,omitempty"`

	// Ducats Amount of ducats required to purchase item
	Ducats *float32 `json:"ducats,omitempty"`

	// Item Item that is being sold
	Item *string `json:"item,omitempty"`
}

// Warframe defines model for warframe.
type Warframe struct {
	Armor              float32            `json:"armor"`
	Aura               string             `json:"aura"`
	Category           *string            `json:"category,omitempty"`
	Color              float32            `json:"color"`
	Components         *[]ShallowItem     `json:"components,omitempty"`
	Conclave           bool               `json:"conclave"`
	Description        string             `json:"description"`
	EstimatedVaultDate *openapitypes.Date `json:"estimatedVaultDate,omitempty"`
	Health             float32            `json:"health"`
	Info               string             `json:"info"`
	Introduced         *Introduced        `json:"introduced,omitempty"`
	Location           string             `json:"location"`
	Mr                 string             `json:"mr"`
	Name               string             `json:"name"`
	Patchlogs          *[]Patchlog        `json:"patchlogs,omitempty"`
	Polarities         []string           `json:"polarities"`
	Power              float32            `json:"power"`
	PrimeArmor         *float32           `json:"prime_armor,omitempty"`
	PrimeAura          *string            `json:"prime_aura,omitempty"`
	PrimeConclave      *string            `json:"prime_conclave,omitempty"`
	PrimeHealth        *float32           `json:"prime_health,omitempty"`
	PrimeMr            *string            `json:"prime_mr,omitempty"`
	PrimePolarities    *[]string          `json:"prime_polarities,omitempty"`
	PrimePower         *string            `json:"prime_power,omitempty"`
	PrimeShield        *float32           `json:"prime_shield,omitempty"`
	PrimeSpeed         *string            `json:"prime_speed,omitempty"`
	PrimeUrl           *string            `json:"prime_url,omitempty"`
	ProductCategory    *string            `json:"productCategory,omitempty"`
	Regex              string             `json:"regex"`
	Shield             float32            `json:"shield"`
	Speed              string             `json:"speed"`
	Thumbnail          string             `json:"thumbnail"`
	Tradable           *bool              `json:"tradable,omitempty"`
	Type               *string            `json:"type,omitempty"`
	UniqueName         *string            `json:"uniqueName,omitempty"`
	Url                string             `json:"url"`
}

// Warframes defines model for warframes.
type Warframes = []Warframe

// Weapon defines model for weapon.
type Weapon struct {
	Attacks            *[]Attack          `json:"attacks,omitempty"`
	BpCost             *string            `json:"bpCost,omitempty"`
	BuildPrice         *int               `json:"buildPrice,omitempty"`
	BuildQuantity      *int               `json:"buildQuantity,omitempty"`
	BuildTime          *int               `json:"buildTime,omitempty"`
	Category           *string            `json:"category,omitempty"`
	Components         *[]ShallowItem     `json:"components,omitempty"`
	ConsumeOnBuild     *bool              `json:"consumeOnBuild,omitempty"`
	CriticalChance     *float32           `json:"criticalChance,omitempty"`
	CriticalMultiplier *float32           `json:"criticalMultiplier,omitempty"`
	Description        *string            `json:"description,omitempty"`
	Disposition        *int               `json:"disposition,omitempty"`
	EstimatedVaultDate *openapitypes.Date `json:"estimatedVaultDate,omitempty"`
	FireRate           *float32           `json:"fireRate,omitempty"`
	Introduced         *Introduced        `json:"introduced,omitempty"`
	MarketCost         *string            `json:"marketCost,omitempty"`
	MasteryReq         *int               `json:"masteryReq,omitempty"`
	Mr                 *float32           `json:"mr,omitempty"`
	Name               *string            `json:"name,omitempty"`
	OmegaAttenuation   *float32           `json:"omegaAttenuation,omitempty"`
	Patchlogs          *[]Patchlog        `json:"patchlogs,omitempty"`
	Polarities         *[]Polarity        `json:"polarities,omitempty"`
	ProcChance         *float32           `json:"procChance,omitempty"`
	ProductCategory    *string            `json:"productCategory,omitempty"`
	ReleaseDate        *float32           `json:"releaseDate,omitempty"`
	RivenDisposition   *float32           `json:"riven_disposition,omitempty"`
	SkipBuildTimePrice *int               `json:"skipBuildTimePrice,omitempty"`

	// Slot Specifies the slot of an item.
	Slot           *int               `json:"slot,omitempty"`
	Tags           *[]string          `json:"tags,omitempty"`
	Thumbnail      *string            `json:"thumbnail,omitempty"`
	TotalDamage    *int               `json:"totalDamage,omitempty"`
	Tradable       *bool              `json:"tradable,omitempty"`
	Type           *string            `json:"type,omitempty"`
	UniqueName     *string            `json:"uniqueName,omitempty"`
	Url            *string            `json:"url,omitempty"`
	VaultDate      *openapitypes.Date `json:"vaultDate,omitempty"`
	Vaulted        *bool              `json:"vaulted,omitempty"`
	WikiaThumbnail *string            `json:"wikiaThumbnail,omitempty"`
	WikiaUrl       *string            `json:"wikiaUrl,omitempty"`
}

// Weapons defines model for weapons.
type Weapons = []WeaponsInner

// WeaponsInner defines model for weapons_inner.
type WeaponsInner struct {
	union json.RawMessage
}

// WorldstateObject defines model for worldstateObject.
type WorldstateObject struct {
	// Activation ISO-8601 formatted timestamp for when the event began
	Activation *time.Time `json:"activation,omitempty"`

	// Active Whether the event is currently active
	Active *bool `json:"active,omitempty"`

	// Expiry ISO-8601 formatted timestamp for when the event is expected to end
	Expiry *time.Time `json:"expiry,omitempty"`

	// Id unique identifier for this object/event/thing
	Id *string `json:"id,omitempty"`

	// StartString Short-time-formatted duration string representing the start of the event
	StartString *string `json:"startString,omitempty"`
}

// Ws Full World State Object
type Ws struct {
	Alerts               []AlertsInner             `json:"alerts"`
	Arbitration          Arbitration               `json:"arbitration"`
	ArchonHunt           ArchonHunt                `json:"archonHunt"`
	CambionCycle         CambionCycle              `json:"cambionCycle"`
	CetusCycle           CetusCycle                `json:"cetusCycle"`
	ConclaveChallenges   []ConclaveChallengesInner `json:"conclaveChallenges"`
	ConstructionProgress Construction              `json:"constructionProgress"`
	DailyDeals           []DailyDealsInner         `json:"dailyDeals"`
	DarkSectors          *[]DarkSectorsInner       `json:"darkSectors,omitempty"`
	EarthCycle           EarthCycle                `json:"earthCycle"`
	Events               []Event                   `json:"events"`
	Fissures             []FissuresInner           `json:"fissures"`
	FlashSales           FlashSales                `json:"flashSales"`
	GlobalUpgrades       []GlobalUpgradesInner     `json:"globalUpgrades"`
	Invasions            []Invasion                `json:"invasions"`
	Kuva                 *[]Arbitration            `json:"kuva,omitempty"`
	News                 []NewsInner               `json:"news"`
	Nightwave            *Nightwave                `json:"nightwave,omitempty"`
	PersistentEnemies    []PersistentEnemiesInner  `json:"persistentEnemies"`
	Simaris              *Simaris                  `json:"simaris,omitempty"`
	Sortie               Sortie                    `json:"sortie"`
	SteelPath            SteelPath                 `json:"steelPath"`
	SyndicateMissions    []SyndicateMission        `json:"syndicateMissions"`
	Timestamp            string                    `json:"timestamp"`
	VallisCycle          VallisCycle               `json:"vallisCycle"`
	VoidTrader           VoidTrader                `json:"voidTrader"`
}

// GetItemsDataParams defines parameters for GetItemsData.
type GetItemsDataParams struct {
	// Only Keys to keep on the object. Comma separated for multiple
	Only *string `form:"only,omitempty" json:"only,omitempty"`

	// Remove Keys to remove on the object. Comma separated for multiple
	Remove *string `form:"remove,omitempty" json:"remove,omitempty"`

	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// SearchItemsDataParams defines parameters for SearchItemsData.
type SearchItemsDataParams struct {
	// Only Keys to keep on the object. Comma separated for multiple
	Only *string `form:"only,omitempty" json:"only,omitempty"`

	// Remove Keys to remove on the object. Comma separated for multiple
	Remove *string `form:"remove,omitempty" json:"remove,omitempty"`

	// By Key to search by on the object
	By *string `form:"by,omitempty" json:"by,omitempty"`

	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// SearchItemDataParams defines parameters for SearchItemData.
type SearchItemDataParams struct {
	// Only Keys to keep on the object. Comma separated for multiple
	Only *string `form:"only,omitempty" json:"only,omitempty"`

	// Remove Keys to remove on the object. Comma separated for multiple
	Remove *string `form:"remove,omitempty" json:"remove,omitempty"`

	// By Key to search by on the object
	By *string `form:"by,omitempty" json:"by,omitempty"`

	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetModsDataParams defines parameters for GetModsData.
type GetModsDataParams struct {
	// Only Keys to keep on the object. Comma separated for multiple
	Only *string `form:"only,omitempty" json:"only,omitempty"`

	// Remove Keys to remove on the object. Comma separated for multiple
	Remove *string `form:"remove,omitempty" json:"remove,omitempty"`

	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// SearchModsDataParams defines parameters for SearchModsData.
type SearchModsDataParams struct {
	// Only Keys to keep on the object. Comma separated for multiple
	Only *string `form:"only,omitempty" json:"only,omitempty"`

	// Remove Keys to remove on the object. Comma separated for multiple
	Remove *string `form:"remove,omitempty" json:"remove,omitempty"`

	// By Key to search by on the object
	By *string `form:"by,omitempty" json:"by,omitempty"`

	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// SearchModDataParams defines parameters for SearchModData.
type SearchModDataParams struct {
	// Only Keys to keep on the object. Comma separated for multiple
	Only *string `form:"only,omitempty" json:"only,omitempty"`

	// Remove Keys to remove on the object. Comma separated for multiple
	Remove *string `form:"remove,omitempty" json:"remove,omitempty"`

	// By Key to search by on the object
	By *string `form:"by,omitempty" json:"by,omitempty"`

	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetWarframesDataParams defines parameters for GetWarframesData.
type GetWarframesDataParams struct {
	// Only Keys to keep on the object. Comma separated for multiple
	Only *string `form:"only,omitempty" json:"only,omitempty"`

	// Remove Keys to remove on the object. Comma separated for multiple
	Remove *string `form:"remove,omitempty" json:"remove,omitempty"`

	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// SearchWarframesDataParams defines parameters for SearchWarframesData.
type SearchWarframesDataParams struct {
	// Only Keys to keep on the object. Comma separated for multiple
	Only *string `form:"only,omitempty" json:"only,omitempty"`

	// Remove Keys to remove on the object. Comma separated for multiple
	Remove *string `form:"remove,omitempty" json:"remove,omitempty"`

	// By Key to search by on the object
	By *string `form:"by,omitempty" json:"by,omitempty"`

	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// SearchWarframeDataParams defines parameters for SearchWarframeData.
type SearchWarframeDataParams struct {
	// Only Keys to keep on the object. Comma separated for multiple
	Only *string `form:"only,omitempty" json:"only,omitempty"`

	// Remove Keys to remove on the object. Comma separated for multiple
	Remove *string `form:"remove,omitempty" json:"remove,omitempty"`

	// By Key to search by on the object
	By *string `form:"by,omitempty" json:"by,omitempty"`

	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetWeaponsDataParams defines parameters for GetWeaponsData.
type GetWeaponsDataParams struct {
	// Only Keys to keep on the object. Comma separated for multiple
	Only *string `form:"only,omitempty" json:"only,omitempty"`

	// Remove Keys to remove on the object. Comma separated for multiple
	Remove *string `form:"remove,omitempty" json:"remove,omitempty"`

	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// SearchWeaponsDataParams defines parameters for SearchWeaponsData.
type SearchWeaponsDataParams struct {
	// Only Keys to keep on the object. Comma separated for multiple
	Only *string `form:"only,omitempty" json:"only,omitempty"`

	// Remove Keys to remove on the object. Comma separated for multiple
	Remove *string `form:"remove,omitempty" json:"remove,omitempty"`

	// By Key to search by on the object
	By *string `form:"by,omitempty" json:"by,omitempty"`

	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// SearchWeaponDataParams defines parameters for SearchWeaponData.
type SearchWeaponDataParams struct {
	// Only Keys to keep on the object. Comma separated for multiple
	Only *string `form:"only,omitempty" json:"only,omitempty"`

	// Remove Keys to remove on the object. Comma separated for multiple
	Remove *string `form:"remove,omitempty" json:"remove,omitempty"`

	// By Key to search by on the object
	By *string `form:"by,omitempty" json:"by,omitempty"`

	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetWorldstateByPlatformParams defines parameters for GetWorldstateByPlatform.
type GetWorldstateByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetAlertsByPlatformParams defines parameters for GetAlertsByPlatform.
type GetAlertsByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetArbitrationByPlatformParams defines parameters for GetArbitrationByPlatform.
type GetArbitrationByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetArchonHuntByPlatformParams defines parameters for GetArchonHuntByPlatform.
type GetArchonHuntByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetCambionByPlatformParams defines parameters for GetCambionByPlatform.
type GetCambionByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetCetusByPlatformParams defines parameters for GetCetusByPlatform.
type GetCetusByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetConclaveChallengesByPlatformParams defines parameters for GetConclaveChallengesByPlatform.
type GetConclaveChallengesByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetConstructionByPlatformParams defines parameters for GetConstructionByPlatform.
type GetConstructionByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetDealsByPlatformParams defines parameters for GetDealsByPlatform.
type GetDealsByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetDarkSectorsByPlatformParams defines parameters for GetDarkSectorsByPlatform.
type GetDarkSectorsByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetEarthByPlatformParams defines parameters for GetEarthByPlatform.
type GetEarthByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetEventsByPlatformParams defines parameters for GetEventsByPlatform.
type GetEventsByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetFissuresByPlatformParams defines parameters for GetFissuresByPlatform.
type GetFissuresByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetSalesByPlatformParams defines parameters for GetSalesByPlatform.
type GetSalesByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetGlobalEffectsByPlatformParams defines parameters for GetGlobalEffectsByPlatform.
type GetGlobalEffectsByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetInvasionsByPlatformParams defines parameters for GetInvasionsByPlatform.
type GetInvasionsByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetKuvaByPlatformParams defines parameters for GetKuvaByPlatform.
type GetKuvaByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetNightwaveByPlatformParams defines parameters for GetNightwaveByPlatform.
type GetNightwaveByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetAcolytesByPlatformParams defines parameters for GetAcolytesByPlatform.
type GetAcolytesByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetRivensByPlatformParams defines parameters for GetRivensByPlatform.
type GetRivensByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetOutpostsByPlatformParams defines parameters for GetOutpostsByPlatform.
type GetOutpostsByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetSimarisByPlatformParams defines parameters for GetSimarisByPlatform.
type GetSimarisByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetSortieByPlatformParams defines parameters for GetSortieByPlatform.
type GetSortieByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetSteelPathByPlatformParams defines parameters for GetSteelPathByPlatform.
type GetSteelPathByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetSyndicatesByPlatformParams defines parameters for GetSyndicatesByPlatform.
type GetSyndicatesByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetTimestampByPlatformParams defines parameters for GetTimestampByPlatform.
type GetTimestampByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetVallisByPlatformParams defines parameters for GetVallisByPlatform.
type GetVallisByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetVarziaByPlatformParams defines parameters for GetVarziaByPlatform.
type GetVarziaByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetBaroByPlatformParams defines parameters for GetBaroByPlatform.
type GetBaroByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// GetVoidTradersByPlatformParams defines parameters for GetVoidTradersByPlatform.
type GetVoidTradersByPlatformParams struct {
	// Language Language to retrieve. With Caching, this has become required if you want your reply to always match your request.
	Language Language `form:"language" json:"language"`

	// AcceptLanguage Language to retrieve. Doesn't always work with caching. See Language query string parameter.
	AcceptLanguage *Language `json:"Accept-Language,omitempty"`
}

// AsItem returns the union data inside the ItemsInner as a Item
func (t ItemsInner) AsItem() (Item, error) {
	var body Item
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromItem overwrites any union data inside the ItemsInner as the provided Item
func (t *ItemsInner) FromItem(v Item) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeItem performs a merge with any union data inside the ItemsInner, using the provided Item
func (t *ItemsInner) MergeItem(v Item) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRangedWeapon returns the union data inside the ItemsInner as a RangedWeapon
func (t ItemsInner) AsRangedWeapon() (RangedWeapon, error) {
	var body RangedWeapon
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRangedWeapon overwrites any union data inside the ItemsInner as the provided RangedWeapon
func (t *ItemsInner) FromRangedWeapon(v RangedWeapon) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRangedWeapon performs a merge with any union data inside the ItemsInner, using the provided RangedWeapon
func (t *ItemsInner) MergeRangedWeapon(v RangedWeapon) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMeleeWeapon returns the union data inside the ItemsInner as a MeleeWeapon
func (t ItemsInner) AsMeleeWeapon() (MeleeWeapon, error) {
	var body MeleeWeapon
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeleeWeapon overwrites any union data inside the ItemsInner as the provided MeleeWeapon
func (t *ItemsInner) FromMeleeWeapon(v MeleeWeapon) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeleeWeapon performs a merge with any union data inside the ItemsInner, using the provided MeleeWeapon
func (t *ItemsInner) MergeMeleeWeapon(v MeleeWeapon) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWeapon returns the union data inside the ItemsInner as a Weapon
func (t ItemsInner) AsWeapon() (Weapon, error) {
	var body Weapon
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWeapon overwrites any union data inside the ItemsInner as the provided Weapon
func (t *ItemsInner) FromWeapon(v Weapon) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWeapon performs a merge with any union data inside the ItemsInner, using the provided Weapon
func (t *ItemsInner) MergeWeapon(v Weapon) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMod returns the union data inside the ItemsInner as a Mod
func (t ItemsInner) AsMod() (Mod, error) {
	var body Mod
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMod overwrites any union data inside the ItemsInner as the provided Mod
func (t *ItemsInner) FromMod(v Mod) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMod performs a merge with any union data inside the ItemsInner, using the provided Mod
func (t *ItemsInner) MergeMod(v Mod) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ItemsInner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ItemsInner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSearchAcolytesData200ResponseInner0 returns the union data inside the SearchAcolytesData200ResponseInner as a SearchAcolytesData200ResponseInner0
func (t SearchAcolytesData200ResponseInner) AsSearchAcolytesData200ResponseInner0() (SearchAcolytesData200ResponseInner0, error) {
	var body SearchAcolytesData200ResponseInner0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchAcolytesData200ResponseInner0 overwrites any union data inside the SearchAcolytesData200ResponseInner as the provided SearchAcolytesData200ResponseInner0
func (t *SearchAcolytesData200ResponseInner) FromSearchAcolytesData200ResponseInner0(v SearchAcolytesData200ResponseInner0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchAcolytesData200ResponseInner0 performs a merge with any union data inside the SearchAcolytesData200ResponseInner, using the provided SearchAcolytesData200ResponseInner0
func (t *SearchAcolytesData200ResponseInner) MergeSearchAcolytesData200ResponseInner0(v SearchAcolytesData200ResponseInner0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SearchAcolytesData200ResponseInner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SearchAcolytesData200ResponseInner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRangedWeapon returns the union data inside the WeaponsInner as a RangedWeapon
func (t WeaponsInner) AsRangedWeapon() (RangedWeapon, error) {
	var body RangedWeapon
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRangedWeapon overwrites any union data inside the WeaponsInner as the provided RangedWeapon
func (t *WeaponsInner) FromRangedWeapon(v RangedWeapon) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRangedWeapon performs a merge with any union data inside the WeaponsInner, using the provided RangedWeapon
func (t *WeaponsInner) MergeRangedWeapon(v RangedWeapon) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMeleeWeapon returns the union data inside the WeaponsInner as a MeleeWeapon
func (t WeaponsInner) AsMeleeWeapon() (MeleeWeapon, error) {
	var body MeleeWeapon
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMeleeWeapon overwrites any union data inside the WeaponsInner as the provided MeleeWeapon
func (t *WeaponsInner) FromMeleeWeapon(v MeleeWeapon) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMeleeWeapon performs a merge with any union data inside the WeaponsInner, using the provided MeleeWeapon
func (t *WeaponsInner) MergeMeleeWeapon(v MeleeWeapon) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t WeaponsInner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *WeaponsInner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a warframestatapi with sane default values
	client := Client{
		Server: server,
	}
	// mutate warframestatapi and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the warframestatapi above.
type ClientInterface interface {
	// GetArcanesData request
	GetArcanesData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchArcanesData request
	SearchArcanesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConclaveData request
	GetConclaveData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchConclavesData request
	SearchConclavesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDropsData request
	SearchDropsData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventsData request
	GetEventsData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchEventsData request
	SearchEventsData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFactionsData request
	GetFactionsData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchFactionsData request
	SearchFactionsData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFissuresData request
	GetFissuresData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchFissuresData request
	SearchFissuresData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetItemsData request
	GetItemsData(ctx context.Context, params *GetItemsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchItemsData request
	SearchItemsData(ctx context.Context, query string, params *SearchItemsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchItemData request
	SearchItemData(ctx context.Context, query string, params *SearchItemDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLanguageData request
	GetLanguageData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchLanguagesData request
	SearchLanguagesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocales request
	GetLocales(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMissionData request
	GetMissionData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchMissionTypesData request
	SearchMissionTypesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModsData request
	GetModsData(ctx context.Context, params *GetModsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchModsData request
	SearchModsData(ctx context.Context, query string, params *SearchModsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchModData request
	SearchModData(ctx context.Context, query string, params *SearchModDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOperationsData request
	GetOperationsData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchOperationsData request
	SearchOperationsData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAcolyteData request
	GetAcolyteData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchAcolytesData request
	SearchAcolytesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNodeData request
	GetNodeData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchNodesData request
	SearchNodesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSortieData request
	GetSortieData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchSortiesData request
	SearchSortiesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyndicateData request
	GetSyndicateData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchSyndicatesData request
	SearchSyndicatesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTutorialData request
	GetTutorialData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchTutorialsData request
	SearchTutorialsData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUpgradeTypesData request
	GetUpgradeTypesData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUpgradeTypesData request
	SearchUpgradeTypesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWarframesData request
	GetWarframesData(ctx context.Context, params *GetWarframesDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchWarframesData request
	SearchWarframesData(ctx context.Context, query string, params *SearchWarframesDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchWarframeData request
	SearchWarframeData(ctx context.Context, query string, params *SearchWarframeDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWeaponsData request
	GetWeaponsData(ctx context.Context, params *GetWeaponsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchWeaponsData request
	SearchWeaponsData(ctx context.Context, query string, params *SearchWeaponsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchWeaponData request
	SearchWeaponData(ctx context.Context, query string, params *SearchWeaponDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorldstateByPlatform request
	GetWorldstateByPlatform(ctx context.Context, platform Platform, params *GetWorldstateByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlertsByPlatform request
	GetAlertsByPlatform(ctx context.Context, platform Platform, params *GetAlertsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArbitrationByPlatform request
	GetArbitrationByPlatform(ctx context.Context, platform Platform, params *GetArbitrationByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArchonHuntByPlatform request
	GetArchonHuntByPlatform(ctx context.Context, platform Platform, params *GetArchonHuntByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCambionByPlatform request
	GetCambionByPlatform(ctx context.Context, platform Platform, params *GetCambionByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCetusByPlatform request
	GetCetusByPlatform(ctx context.Context, platform Platform, params *GetCetusByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConclaveChallengesByPlatform request
	GetConclaveChallengesByPlatform(ctx context.Context, platform Platform, params *GetConclaveChallengesByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConstructionByPlatform request
	GetConstructionByPlatform(ctx context.Context, platform Platform, params *GetConstructionByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDealsByPlatform request
	GetDealsByPlatform(ctx context.Context, platform Platform, params *GetDealsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDarkSectorsByPlatform request
	GetDarkSectorsByPlatform(ctx context.Context, platform Platform, params *GetDarkSectorsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEarthByPlatform request
	GetEarthByPlatform(ctx context.Context, platform Platform, params *GetEarthByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventsByPlatform request
	GetEventsByPlatform(ctx context.Context, platform Platform, params *GetEventsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFissuresByPlatform request
	GetFissuresByPlatform(ctx context.Context, platform Platform, params *GetFissuresByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSalesByPlatform request
	GetSalesByPlatform(ctx context.Context, platform Platform, params *GetSalesByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobalEffectsByPlatform request
	GetGlobalEffectsByPlatform(ctx context.Context, platform Platform, params *GetGlobalEffectsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvasionsByPlatform request
	GetInvasionsByPlatform(ctx context.Context, platform Platform, params *GetInvasionsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKuvaByPlatform request
	GetKuvaByPlatform(ctx context.Context, platform Platform, params *GetKuvaByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNewsByPlatform request
	GetNewsByPlatform(ctx context.Context, platform Platform, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNightwaveByPlatform request
	GetNightwaveByPlatform(ctx context.Context, platform Platform, params *GetNightwaveByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAcolytesByPlatform request
	GetAcolytesByPlatform(ctx context.Context, platform Platform, params *GetAcolytesByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRivensByPlatform request
	GetRivensByPlatform(ctx context.Context, platform Platform, params *GetRivensByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchRivensByPlatform request
	SearchRivensByPlatform(ctx context.Context, platform Platform, query string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutpostsByPlatform request
	GetOutpostsByPlatform(ctx context.Context, platform Platform, params *GetOutpostsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSimarisByPlatform request
	GetSimarisByPlatform(ctx context.Context, platform Platform, params *GetSimarisByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSortieByPlatform request
	GetSortieByPlatform(ctx context.Context, platform Platform, params *GetSortieByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSteelPathByPlatform request
	GetSteelPathByPlatform(ctx context.Context, platform Platform, params *GetSteelPathByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSyndicatesByPlatform request
	GetSyndicatesByPlatform(ctx context.Context, platform Platform, params *GetSyndicatesByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTimestampByPlatform request
	GetTimestampByPlatform(ctx context.Context, platform Platform, params *GetTimestampByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVallisByPlatform request
	GetVallisByPlatform(ctx context.Context, platform Platform, params *GetVallisByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVarziaByPlatform request
	GetVarziaByPlatform(ctx context.Context, platform Platform, params *GetVarziaByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBaroByPlatform request
	GetBaroByPlatform(ctx context.Context, platform Platform, params *GetBaroByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVoidTradersByPlatform request
	GetVoidTradersByPlatform(ctx context.Context, platform Platform, params *GetVoidTradersByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetArcanesData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArcanesDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchArcanesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchArcanesDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConclaveData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConclaveDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchConclavesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchConclavesDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDropsData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDropsDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventsData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventsDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchEventsData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchEventsDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFactionsData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFactionsDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchFactionsData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchFactionsDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFissuresData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFissuresDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchFissuresData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchFissuresDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetItemsData(ctx context.Context, params *GetItemsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetItemsDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchItemsData(ctx context.Context, query string, params *SearchItemsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchItemsDataRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchItemData(ctx context.Context, query string, params *SearchItemDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchItemDataRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLanguageData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLanguageDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchLanguagesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchLanguagesDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocales(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocalesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMissionData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMissionDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchMissionTypesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchMissionTypesDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModsData(ctx context.Context, params *GetModsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModsDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchModsData(ctx context.Context, query string, params *SearchModsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchModsDataRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchModData(ctx context.Context, query string, params *SearchModDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchModDataRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOperationsData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOperationsDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchOperationsData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchOperationsDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAcolyteData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAcolyteDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchAcolytesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchAcolytesDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNodeData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNodeDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchNodesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchNodesDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSortieData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSortieDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchSortiesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchSortiesDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyndicateData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyndicateDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchSyndicatesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchSyndicatesDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTutorialData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTutorialDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchTutorialsData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchTutorialsDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUpgradeTypesData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUpgradeTypesDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUpgradeTypesData(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUpgradeTypesDataRequest(c.Server, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWarframesData(ctx context.Context, params *GetWarframesDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWarframesDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchWarframesData(ctx context.Context, query string, params *SearchWarframesDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchWarframesDataRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchWarframeData(ctx context.Context, query string, params *SearchWarframeDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchWarframeDataRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWeaponsData(ctx context.Context, params *GetWeaponsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWeaponsDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchWeaponsData(ctx context.Context, query string, params *SearchWeaponsDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchWeaponsDataRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchWeaponData(ctx context.Context, query string, params *SearchWeaponDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchWeaponDataRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorldstateByPlatform(ctx context.Context, platform Platform, params *GetWorldstateByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorldstateByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlertsByPlatform(ctx context.Context, platform Platform, params *GetAlertsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlertsByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArbitrationByPlatform(ctx context.Context, platform Platform, params *GetArbitrationByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArbitrationByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArchonHuntByPlatform(ctx context.Context, platform Platform, params *GetArchonHuntByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArchonHuntByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCambionByPlatform(ctx context.Context, platform Platform, params *GetCambionByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCambionByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCetusByPlatform(ctx context.Context, platform Platform, params *GetCetusByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCetusByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConclaveChallengesByPlatform(ctx context.Context, platform Platform, params *GetConclaveChallengesByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConclaveChallengesByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConstructionByPlatform(ctx context.Context, platform Platform, params *GetConstructionByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConstructionByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDealsByPlatform(ctx context.Context, platform Platform, params *GetDealsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDealsByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDarkSectorsByPlatform(ctx context.Context, platform Platform, params *GetDarkSectorsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDarkSectorsByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEarthByPlatform(ctx context.Context, platform Platform, params *GetEarthByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEarthByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventsByPlatform(ctx context.Context, platform Platform, params *GetEventsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventsByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFissuresByPlatform(ctx context.Context, platform Platform, params *GetFissuresByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFissuresByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSalesByPlatform(ctx context.Context, platform Platform, params *GetSalesByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSalesByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobalEffectsByPlatform(ctx context.Context, platform Platform, params *GetGlobalEffectsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalEffectsByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvasionsByPlatform(ctx context.Context, platform Platform, params *GetInvasionsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvasionsByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKuvaByPlatform(ctx context.Context, platform Platform, params *GetKuvaByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKuvaByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNewsByPlatform(ctx context.Context, platform Platform, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNewsByPlatformRequest(c.Server, platform)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNightwaveByPlatform(ctx context.Context, platform Platform, params *GetNightwaveByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNightwaveByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAcolytesByPlatform(ctx context.Context, platform Platform, params *GetAcolytesByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAcolytesByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRivensByPlatform(ctx context.Context, platform Platform, params *GetRivensByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRivensByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRivensByPlatform(ctx context.Context, platform Platform, query string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRivensByPlatformRequest(c.Server, platform, query)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutpostsByPlatform(ctx context.Context, platform Platform, params *GetOutpostsByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutpostsByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSimarisByPlatform(ctx context.Context, platform Platform, params *GetSimarisByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSimarisByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSortieByPlatform(ctx context.Context, platform Platform, params *GetSortieByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSortieByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSteelPathByPlatform(ctx context.Context, platform Platform, params *GetSteelPathByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSteelPathByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSyndicatesByPlatform(ctx context.Context, platform Platform, params *GetSyndicatesByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSyndicatesByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTimestampByPlatform(ctx context.Context, platform Platform, params *GetTimestampByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTimestampByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVallisByPlatform(ctx context.Context, platform Platform, params *GetVallisByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVallisByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVarziaByPlatform(ctx context.Context, platform Platform, params *GetVarziaByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVarziaByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBaroByPlatform(ctx context.Context, platform Platform, params *GetBaroByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBaroByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVoidTradersByPlatform(ctx context.Context, platform Platform, params *GetVoidTradersByPlatformParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVoidTradersByPlatformRequest(c.Server, platform, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetArcanesDataRequest generates requests for GetArcanesData
func NewGetArcanesDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/arcanes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchArcanesDataRequest generates requests for SearchArcanesData
func NewSearchArcanesDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/arcanes/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConclaveDataRequest generates requests for GetConclaveData
func NewGetConclaveDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conclave")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchConclavesDataRequest generates requests for SearchConclavesData
func NewSearchConclavesDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/conclave/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchDropsDataRequest generates requests for SearchDropsData
func NewSearchDropsDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/drops/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventsDataRequest generates requests for GetEventsData
func NewGetEventsDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchEventsDataRequest generates requests for SearchEventsData
func NewSearchEventsDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFactionsDataRequest generates requests for GetFactionsData
func NewGetFactionsDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/factions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchFactionsDataRequest generates requests for SearchFactionsData
func NewSearchFactionsDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/factions/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFissuresDataRequest generates requests for GetFissuresData
func NewGetFissuresDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fissureModifiers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchFissuresDataRequest generates requests for SearchFissuresData
func NewSearchFissuresDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fissureModifiers/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetItemsDataRequest generates requests for GetItemsData
func NewGetItemsDataRequest(server string, params *GetItemsDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Only != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only", runtime.ParamLocationQuery, *params.Only); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remove != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove", runtime.ParamLocationQuery, *params.Remove); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewSearchItemsDataRequest generates requests for SearchItemsData
func NewSearchItemsDataRequest(server string, query string, params *SearchItemsDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Only != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only", runtime.ParamLocationQuery, *params.Only); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remove != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove", runtime.ParamLocationQuery, *params.Remove); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.By != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, *params.By); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewSearchItemDataRequest generates requests for SearchItemData
func NewSearchItemDataRequest(server string, query string, params *SearchItemDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Only != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only", runtime.ParamLocationQuery, *params.Only); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remove != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove", runtime.ParamLocationQuery, *params.Remove); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.By != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, *params.By); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetLanguageDataRequest generates requests for GetLanguageData
func NewGetLanguageDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/languages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchLanguagesDataRequest generates requests for SearchLanguagesData
func NewSearchLanguagesDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/languages/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocalesRequest generates requests for GetLocales
func NewGetLocalesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locales")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMissionDataRequest generates requests for GetMissionData
func NewGetMissionDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/missionTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchMissionTypesDataRequest generates requests for SearchMissionTypesData
func NewSearchMissionTypesDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/missionTypes/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetModsDataRequest generates requests for GetModsData
func NewGetModsDataRequest(server string, params *GetModsDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Only != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only", runtime.ParamLocationQuery, *params.Only); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remove != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove", runtime.ParamLocationQuery, *params.Remove); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewSearchModsDataRequest generates requests for SearchModsData
func NewSearchModsDataRequest(server string, query string, params *SearchModsDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Only != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only", runtime.ParamLocationQuery, *params.Only); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remove != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove", runtime.ParamLocationQuery, *params.Remove); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.By != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, *params.By); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewSearchModDataRequest generates requests for SearchModData
func NewSearchModDataRequest(server string, query string, params *SearchModDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Only != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only", runtime.ParamLocationQuery, *params.Only); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remove != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove", runtime.ParamLocationQuery, *params.Remove); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.By != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, *params.By); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetOperationsDataRequest generates requests for GetOperationsData
func NewGetOperationsDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/operationTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchOperationsDataRequest generates requests for SearchOperationsData
func NewSearchOperationsDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/operationTypes/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAcolyteDataRequest generates requests for GetAcolyteData
func NewGetAcolyteDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistentEnemy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchAcolytesDataRequest generates requests for SearchAcolytesData
func NewSearchAcolytesDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistentEnemy/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNodeDataRequest generates requests for GetNodeData
func NewGetNodeDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/solNodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchNodesDataRequest generates requests for SearchNodesData
func NewSearchNodesDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/solNodes/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSortieDataRequest generates requests for GetSortieData
func NewGetSortieDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sortie")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchSortiesDataRequest generates requests for SearchSortiesData
func NewSearchSortiesDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sortie/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSyndicateDataRequest generates requests for GetSyndicateData
func NewGetSyndicateDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syndicates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchSyndicatesDataRequest generates requests for SearchSyndicatesData
func NewSearchSyndicatesDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/syndicates/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTutorialDataRequest generates requests for GetTutorialData
func NewGetTutorialDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tutorials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchTutorialsDataRequest generates requests for SearchTutorialsData
func NewSearchTutorialsDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tutorials/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUpgradeTypesDataRequest generates requests for GetUpgradeTypesData
func NewGetUpgradeTypesDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upgradeTypes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchUpgradeTypesDataRequest generates requests for SearchUpgradeTypesData
func NewSearchUpgradeTypesDataRequest(server string, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upgradeTypes/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWarframesDataRequest generates requests for GetWarframesData
func NewGetWarframesDataRequest(server string, params *GetWarframesDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/warframes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Only != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only", runtime.ParamLocationQuery, *params.Only); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remove != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove", runtime.ParamLocationQuery, *params.Remove); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewSearchWarframesDataRequest generates requests for SearchWarframesData
func NewSearchWarframesDataRequest(server string, query string, params *SearchWarframesDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/warframes/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Only != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only", runtime.ParamLocationQuery, *params.Only); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remove != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove", runtime.ParamLocationQuery, *params.Remove); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.By != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, *params.By); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewSearchWarframeDataRequest generates requests for SearchWarframeData
func NewSearchWarframeDataRequest(server string, query string, params *SearchWarframeDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/warframes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Only != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only", runtime.ParamLocationQuery, *params.Only); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remove != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove", runtime.ParamLocationQuery, *params.Remove); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.By != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, *params.By); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetWeaponsDataRequest generates requests for GetWeaponsData
func NewGetWeaponsDataRequest(server string, params *GetWeaponsDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/weapons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Only != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only", runtime.ParamLocationQuery, *params.Only); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remove != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove", runtime.ParamLocationQuery, *params.Remove); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewSearchWeaponsDataRequest generates requests for SearchWeaponsData
func NewSearchWeaponsDataRequest(server string, query string, params *SearchWeaponsDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/weapons/search/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Only != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only", runtime.ParamLocationQuery, *params.Only); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remove != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove", runtime.ParamLocationQuery, *params.Remove); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.By != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, *params.By); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewSearchWeaponDataRequest generates requests for SearchWeaponData
func NewSearchWeaponDataRequest(server string, query string, params *SearchWeaponDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/weapons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Only != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only", runtime.ParamLocationQuery, *params.Only); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remove != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove", runtime.ParamLocationQuery, *params.Remove); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.By != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, *params.By); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetWorldstateByPlatformRequest generates requests for GetWorldstateByPlatform
func NewGetWorldstateByPlatformRequest(server string, platform Platform, params *GetWorldstateByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetAlertsByPlatformRequest generates requests for GetAlertsByPlatform
func NewGetAlertsByPlatformRequest(server string, platform Platform, params *GetAlertsByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/alerts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetArbitrationByPlatformRequest generates requests for GetArbitrationByPlatform
func NewGetArbitrationByPlatformRequest(server string, platform Platform, params *GetArbitrationByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/arbitration", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetArchonHuntByPlatformRequest generates requests for GetArchonHuntByPlatform
func NewGetArchonHuntByPlatformRequest(server string, platform Platform, params *GetArchonHuntByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/archonHunt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetCambionByPlatformRequest generates requests for GetCambionByPlatform
func NewGetCambionByPlatformRequest(server string, platform Platform, params *GetCambionByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/cambionCycle", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetCetusByPlatformRequest generates requests for GetCetusByPlatform
func NewGetCetusByPlatformRequest(server string, platform Platform, params *GetCetusByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/cetusCycle", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetConclaveChallengesByPlatformRequest generates requests for GetConclaveChallengesByPlatform
func NewGetConclaveChallengesByPlatformRequest(server string, platform Platform, params *GetConclaveChallengesByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/conclaveChallenges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetConstructionByPlatformRequest generates requests for GetConstructionByPlatform
func NewGetConstructionByPlatformRequest(server string, platform Platform, params *GetConstructionByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/constructionProgress", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetDealsByPlatformRequest generates requests for GetDealsByPlatform
func NewGetDealsByPlatformRequest(server string, platform Platform, params *GetDealsByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/dailyDeals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetDarkSectorsByPlatformRequest generates requests for GetDarkSectorsByPlatform
func NewGetDarkSectorsByPlatformRequest(server string, platform Platform, params *GetDarkSectorsByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/darkSectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetEarthByPlatformRequest generates requests for GetEarthByPlatform
func NewGetEarthByPlatformRequest(server string, platform Platform, params *GetEarthByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/earthCycle", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetEventsByPlatformRequest generates requests for GetEventsByPlatform
func NewGetEventsByPlatformRequest(server string, platform Platform, params *GetEventsByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetFissuresByPlatformRequest generates requests for GetFissuresByPlatform
func NewGetFissuresByPlatformRequest(server string, platform Platform, params *GetFissuresByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/fissures", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetSalesByPlatformRequest generates requests for GetSalesByPlatform
func NewGetSalesByPlatformRequest(server string, platform Platform, params *GetSalesByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/flashSales", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetGlobalEffectsByPlatformRequest generates requests for GetGlobalEffectsByPlatform
func NewGetGlobalEffectsByPlatformRequest(server string, platform Platform, params *GetGlobalEffectsByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/globalUpgrades", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetInvasionsByPlatformRequest generates requests for GetInvasionsByPlatform
func NewGetInvasionsByPlatformRequest(server string, platform Platform, params *GetInvasionsByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/invasions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetKuvaByPlatformRequest generates requests for GetKuvaByPlatform
func NewGetKuvaByPlatformRequest(server string, platform Platform, params *GetKuvaByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/kuva", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetNewsByPlatformRequest generates requests for GetNewsByPlatform
func NewGetNewsByPlatformRequest(server string, platform Platform) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/news", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNightwaveByPlatformRequest generates requests for GetNightwaveByPlatform
func NewGetNightwaveByPlatformRequest(server string, platform Platform, params *GetNightwaveByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/nightwave", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetAcolytesByPlatformRequest generates requests for GetAcolytesByPlatform
func NewGetAcolytesByPlatformRequest(server string, platform Platform, params *GetAcolytesByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/persistentEnemies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetRivensByPlatformRequest generates requests for GetRivensByPlatform
func NewGetRivensByPlatformRequest(server string, platform Platform, params *GetRivensByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/rivens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewSearchRivensByPlatformRequest generates requests for SearchRivensByPlatform
func NewSearchRivensByPlatformRequest(server string, platform Platform, query string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/rivens/search/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOutpostsByPlatformRequest generates requests for GetOutpostsByPlatform
func NewGetOutpostsByPlatformRequest(server string, platform Platform, params *GetOutpostsByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/sentientOutposts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetSimarisByPlatformRequest generates requests for GetSimarisByPlatform
func NewGetSimarisByPlatformRequest(server string, platform Platform, params *GetSimarisByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/simaris", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetSortieByPlatformRequest generates requests for GetSortieByPlatform
func NewGetSortieByPlatformRequest(server string, platform Platform, params *GetSortieByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/sortie", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetSteelPathByPlatformRequest generates requests for GetSteelPathByPlatform
func NewGetSteelPathByPlatformRequest(server string, platform Platform, params *GetSteelPathByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/steelPath", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetSyndicatesByPlatformRequest generates requests for GetSyndicatesByPlatform
func NewGetSyndicatesByPlatformRequest(server string, platform Platform, params *GetSyndicatesByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/syndicateMissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetTimestampByPlatformRequest generates requests for GetTimestampByPlatform
func NewGetTimestampByPlatformRequest(server string, platform Platform, params *GetTimestampByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/timestamp", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetVallisByPlatformRequest generates requests for GetVallisByPlatform
func NewGetVallisByPlatformRequest(server string, platform Platform, params *GetVallisByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/vallisCycle", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetVarziaByPlatformRequest generates requests for GetVarziaByPlatform
func NewGetVarziaByPlatformRequest(server string, platform Platform, params *GetVarziaByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/vaultTrader", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetBaroByPlatformRequest generates requests for GetBaroByPlatform
func NewGetBaroByPlatformRequest(server string, platform Platform, params *GetBaroByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/voidTrader", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

// NewGetVoidTradersByPlatformRequest generates requests for GetVoidTradersByPlatform
func NewGetVoidTradersByPlatformRequest(server string, platform Platform, params *GetVoidTradersByPlatformParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "platform", runtime.ParamLocationPath, platform)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/voidTraders", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, params.Language); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.AcceptLanguage != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept-Language", runtime.ParamLocationHeader, *params.AcceptLanguage)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept-Language", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the warframestatapi with responses above.
type ClientWithResponsesInterface interface {
	// GetArcanesDataWithResponse request
	GetArcanesDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetArcanesDataResponse, error)

	// SearchArcanesDataWithResponse request
	SearchArcanesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchArcanesDataResponse, error)

	// GetConclaveDataWithResponse request
	GetConclaveDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConclaveDataResponse, error)

	// SearchConclavesDataWithResponse request
	SearchConclavesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchConclavesDataResponse, error)

	// SearchDropsDataWithResponse request
	SearchDropsDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchDropsDataResponse, error)

	// GetEventsDataWithResponse request
	GetEventsDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEventsDataResponse, error)

	// SearchEventsDataWithResponse request
	SearchEventsDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchEventsDataResponse, error)

	// GetFactionsDataWithResponse request
	GetFactionsDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFactionsDataResponse, error)

	// SearchFactionsDataWithResponse request
	SearchFactionsDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchFactionsDataResponse, error)

	// GetFissuresDataWithResponse request
	GetFissuresDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFissuresDataResponse, error)

	// SearchFissuresDataWithResponse request
	SearchFissuresDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchFissuresDataResponse, error)

	// GetItemsDataWithResponse request
	GetItemsDataWithResponse(ctx context.Context, params *GetItemsDataParams, reqEditors ...RequestEditorFn) (*GetItemsDataResponse, error)

	// SearchItemsDataWithResponse request
	SearchItemsDataWithResponse(ctx context.Context, query string, params *SearchItemsDataParams, reqEditors ...RequestEditorFn) (*SearchItemsDataResponse, error)

	// SearchItemDataWithResponse request
	SearchItemDataWithResponse(ctx context.Context, query string, params *SearchItemDataParams, reqEditors ...RequestEditorFn) (*SearchItemDataResponse, error)

	// GetLanguageDataWithResponse request
	GetLanguageDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLanguageDataResponse, error)

	// SearchLanguagesDataWithResponse request
	SearchLanguagesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchLanguagesDataResponse, error)

	// GetLocalesWithResponse request
	GetLocalesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocalesResponse, error)

	// GetMissionDataWithResponse request
	GetMissionDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMissionDataResponse, error)

	// SearchMissionTypesDataWithResponse request
	SearchMissionTypesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchMissionTypesDataResponse, error)

	// GetModsDataWithResponse request
	GetModsDataWithResponse(ctx context.Context, params *GetModsDataParams, reqEditors ...RequestEditorFn) (*GetModsDataResponse, error)

	// SearchModsDataWithResponse request
	SearchModsDataWithResponse(ctx context.Context, query string, params *SearchModsDataParams, reqEditors ...RequestEditorFn) (*SearchModsDataResponse, error)

	// SearchModDataWithResponse request
	SearchModDataWithResponse(ctx context.Context, query string, params *SearchModDataParams, reqEditors ...RequestEditorFn) (*SearchModDataResponse, error)

	// GetOperationsDataWithResponse request
	GetOperationsDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOperationsDataResponse, error)

	// SearchOperationsDataWithResponse request
	SearchOperationsDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchOperationsDataResponse, error)

	// GetAcolyteDataWithResponse request
	GetAcolyteDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAcolyteDataResponse, error)

	// SearchAcolytesDataWithResponse request
	SearchAcolytesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchAcolytesDataResponse, error)

	// GetNodeDataWithResponse request
	GetNodeDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNodeDataResponse, error)

	// SearchNodesDataWithResponse request
	SearchNodesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchNodesDataResponse, error)

	// GetSortieDataWithResponse request
	GetSortieDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSortieDataResponse, error)

	// SearchSortiesDataWithResponse request
	SearchSortiesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchSortiesDataResponse, error)

	// GetSyndicateDataWithResponse request
	GetSyndicateDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSyndicateDataResponse, error)

	// SearchSyndicatesDataWithResponse request
	SearchSyndicatesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchSyndicatesDataResponse, error)

	// GetTutorialDataWithResponse request
	GetTutorialDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTutorialDataResponse, error)

	// SearchTutorialsDataWithResponse request
	SearchTutorialsDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchTutorialsDataResponse, error)

	// GetUpgradeTypesDataWithResponse request
	GetUpgradeTypesDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUpgradeTypesDataResponse, error)

	// SearchUpgradeTypesDataWithResponse request
	SearchUpgradeTypesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchUpgradeTypesDataResponse, error)

	// GetWarframesDataWithResponse request
	GetWarframesDataWithResponse(ctx context.Context, params *GetWarframesDataParams, reqEditors ...RequestEditorFn) (*GetWarframesDataResponse, error)

	// SearchWarframesDataWithResponse request
	SearchWarframesDataWithResponse(ctx context.Context, query string, params *SearchWarframesDataParams, reqEditors ...RequestEditorFn) (*SearchWarframesDataResponse, error)

	// SearchWarframeDataWithResponse request
	SearchWarframeDataWithResponse(ctx context.Context, query string, params *SearchWarframeDataParams, reqEditors ...RequestEditorFn) (*SearchWarframeDataResponse, error)

	// GetWeaponsDataWithResponse request
	GetWeaponsDataWithResponse(ctx context.Context, params *GetWeaponsDataParams, reqEditors ...RequestEditorFn) (*GetWeaponsDataResponse, error)

	// SearchWeaponsDataWithResponse request
	SearchWeaponsDataWithResponse(ctx context.Context, query string, params *SearchWeaponsDataParams, reqEditors ...RequestEditorFn) (*SearchWeaponsDataResponse, error)

	// SearchWeaponDataWithResponse request
	SearchWeaponDataWithResponse(ctx context.Context, query string, params *SearchWeaponDataParams, reqEditors ...RequestEditorFn) (*SearchWeaponDataResponse, error)

	// GetWorldstateByPlatformWithResponse request
	GetWorldstateByPlatformWithResponse(ctx context.Context, platform Platform, params *GetWorldstateByPlatformParams, reqEditors ...RequestEditorFn) (*GetWorldstateByPlatformResponse, error)

	// GetAlertsByPlatformWithResponse request
	GetAlertsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetAlertsByPlatformParams, reqEditors ...RequestEditorFn) (*GetAlertsByPlatformResponse, error)

	// GetArbitrationByPlatformWithResponse request
	GetArbitrationByPlatformWithResponse(ctx context.Context, platform Platform, params *GetArbitrationByPlatformParams, reqEditors ...RequestEditorFn) (*GetArbitrationByPlatformResponse, error)

	// GetArchonHuntByPlatformWithResponse request
	GetArchonHuntByPlatformWithResponse(ctx context.Context, platform Platform, params *GetArchonHuntByPlatformParams, reqEditors ...RequestEditorFn) (*GetArchonHuntByPlatformResponse, error)

	// GetCambionByPlatformWithResponse request
	GetCambionByPlatformWithResponse(ctx context.Context, platform Platform, params *GetCambionByPlatformParams, reqEditors ...RequestEditorFn) (*GetCambionByPlatformResponse, error)

	// GetCetusByPlatformWithResponse request
	GetCetusByPlatformWithResponse(ctx context.Context, platform Platform, params *GetCetusByPlatformParams, reqEditors ...RequestEditorFn) (*GetCetusByPlatformResponse, error)

	// GetConclaveChallengesByPlatformWithResponse request
	GetConclaveChallengesByPlatformWithResponse(ctx context.Context, platform Platform, params *GetConclaveChallengesByPlatformParams, reqEditors ...RequestEditorFn) (*GetConclaveChallengesByPlatformResponse, error)

	// GetConstructionByPlatformWithResponse request
	GetConstructionByPlatformWithResponse(ctx context.Context, platform Platform, params *GetConstructionByPlatformParams, reqEditors ...RequestEditorFn) (*GetConstructionByPlatformResponse, error)

	// GetDealsByPlatformWithResponse request
	GetDealsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetDealsByPlatformParams, reqEditors ...RequestEditorFn) (*GetDealsByPlatformResponse, error)

	// GetDarkSectorsByPlatformWithResponse request
	GetDarkSectorsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetDarkSectorsByPlatformParams, reqEditors ...RequestEditorFn) (*GetDarkSectorsByPlatformResponse, error)

	// GetEarthByPlatformWithResponse request
	GetEarthByPlatformWithResponse(ctx context.Context, platform Platform, params *GetEarthByPlatformParams, reqEditors ...RequestEditorFn) (*GetEarthByPlatformResponse, error)

	// GetEventsByPlatformWithResponse request
	GetEventsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetEventsByPlatformParams, reqEditors ...RequestEditorFn) (*GetEventsByPlatformResponse, error)

	// GetFissuresByPlatformWithResponse request
	GetFissuresByPlatformWithResponse(ctx context.Context, platform Platform, params *GetFissuresByPlatformParams, reqEditors ...RequestEditorFn) (*GetFissuresByPlatformResponse, error)

	// GetSalesByPlatformWithResponse request
	GetSalesByPlatformWithResponse(ctx context.Context, platform Platform, params *GetSalesByPlatformParams, reqEditors ...RequestEditorFn) (*GetSalesByPlatformResponse, error)

	// GetGlobalEffectsByPlatformWithResponse request
	GetGlobalEffectsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetGlobalEffectsByPlatformParams, reqEditors ...RequestEditorFn) (*GetGlobalEffectsByPlatformResponse, error)

	// GetInvasionsByPlatformWithResponse request
	GetInvasionsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetInvasionsByPlatformParams, reqEditors ...RequestEditorFn) (*GetInvasionsByPlatformResponse, error)

	// GetKuvaByPlatformWithResponse request
	GetKuvaByPlatformWithResponse(ctx context.Context, platform Platform, params *GetKuvaByPlatformParams, reqEditors ...RequestEditorFn) (*GetKuvaByPlatformResponse, error)

	// GetNewsByPlatformWithResponse request
	GetNewsByPlatformWithResponse(ctx context.Context, platform Platform, reqEditors ...RequestEditorFn) (*GetNewsByPlatformResponse, error)

	// GetNightwaveByPlatformWithResponse request
	GetNightwaveByPlatformWithResponse(ctx context.Context, platform Platform, params *GetNightwaveByPlatformParams, reqEditors ...RequestEditorFn) (*GetNightwaveByPlatformResponse, error)

	// GetAcolytesByPlatformWithResponse request
	GetAcolytesByPlatformWithResponse(ctx context.Context, platform Platform, params *GetAcolytesByPlatformParams, reqEditors ...RequestEditorFn) (*GetAcolytesByPlatformResponse, error)

	// GetRivensByPlatformWithResponse request
	GetRivensByPlatformWithResponse(ctx context.Context, platform Platform, params *GetRivensByPlatformParams, reqEditors ...RequestEditorFn) (*GetRivensByPlatformResponse, error)

	// SearchRivensByPlatformWithResponse request
	SearchRivensByPlatformWithResponse(ctx context.Context, platform Platform, query string, reqEditors ...RequestEditorFn) (*SearchRivensByPlatformResponse, error)

	// GetOutpostsByPlatformWithResponse request
	GetOutpostsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetOutpostsByPlatformParams, reqEditors ...RequestEditorFn) (*GetOutpostsByPlatformResponse, error)

	// GetSimarisByPlatformWithResponse request
	GetSimarisByPlatformWithResponse(ctx context.Context, platform Platform, params *GetSimarisByPlatformParams, reqEditors ...RequestEditorFn) (*GetSimarisByPlatformResponse, error)

	// GetSortieByPlatformWithResponse request
	GetSortieByPlatformWithResponse(ctx context.Context, platform Platform, params *GetSortieByPlatformParams, reqEditors ...RequestEditorFn) (*GetSortieByPlatformResponse, error)

	// GetSteelPathByPlatformWithResponse request
	GetSteelPathByPlatformWithResponse(ctx context.Context, platform Platform, params *GetSteelPathByPlatformParams, reqEditors ...RequestEditorFn) (*GetSteelPathByPlatformResponse, error)

	// GetSyndicatesByPlatformWithResponse request
	GetSyndicatesByPlatformWithResponse(ctx context.Context, platform Platform, params *GetSyndicatesByPlatformParams, reqEditors ...RequestEditorFn) (*GetSyndicatesByPlatformResponse, error)

	// GetTimestampByPlatformWithResponse request
	GetTimestampByPlatformWithResponse(ctx context.Context, platform Platform, params *GetTimestampByPlatformParams, reqEditors ...RequestEditorFn) (*GetTimestampByPlatformResponse, error)

	// GetVallisByPlatformWithResponse request
	GetVallisByPlatformWithResponse(ctx context.Context, platform Platform, params *GetVallisByPlatformParams, reqEditors ...RequestEditorFn) (*GetVallisByPlatformResponse, error)

	// GetVarziaByPlatformWithResponse request
	GetVarziaByPlatformWithResponse(ctx context.Context, platform Platform, params *GetVarziaByPlatformParams, reqEditors ...RequestEditorFn) (*GetVarziaByPlatformResponse, error)

	// GetBaroByPlatformWithResponse request
	GetBaroByPlatformWithResponse(ctx context.Context, platform Platform, params *GetBaroByPlatformParams, reqEditors ...RequestEditorFn) (*GetBaroByPlatformResponse, error)

	// GetVoidTradersByPlatformWithResponse request
	GetVoidTradersByPlatformWithResponse(ctx context.Context, platform Platform, params *GetVoidTradersByPlatformParams, reqEditors ...RequestEditorFn) (*GetVoidTradersByPlatformResponse, error)
}

type GetArcanesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Arcane
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetArcanesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArcanesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchArcanesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Arcane
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchArcanesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchArcanesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConclaveDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Conclave
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetConclaveDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConclaveDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchConclavesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Conclave
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchConclavesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchConclavesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDropsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Drops
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchDropsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDropsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetEventsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchEventsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchEventsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchEventsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFactionsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Factions
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetFactionsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFactionsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchFactionsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Factions
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchFactionsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchFactionsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFissuresDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FissureModifiers
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetFissuresDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFissuresDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchFissuresDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FissureModifiers
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchFissuresDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchFissuresDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetItemsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Items
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetItemsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetItemsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchItemsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Items
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchItemsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchItemsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchItemDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Item
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchItemDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchItemDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLanguageDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Languages
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetLanguageDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLanguageDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchLanguagesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Languages
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchLanguagesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchLanguagesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocalesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Language
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetLocalesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocalesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMissionDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MissionTypes
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetMissionDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMissionDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchMissionTypesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MissionTypes
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchMissionTypesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchMissionTypesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Mod
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetModsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchModsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Mod
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchModsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchModsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchModDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Mod
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchModDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchModDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOperationsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OperationTypes
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetOperationsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOperationsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchOperationsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OperationTypes
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchOperationsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchOperationsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAcolyteDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AcolyteI18n
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetAcolyteDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAcolyteDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchAcolytesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SearchAcolytesData200ResponseInner
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchAcolytesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchAcolytesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNodeDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SolNode
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetNodeDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNodeDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchNodesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SolNodeSearch
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchNodesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchNodesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSortieDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SortieData
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetSortieDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSortieDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchSortiesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SortieData
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchSortiesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchSortiesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyndicateDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Syndicates
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetSyndicateDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyndicateDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchSyndicatesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Syndicates
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchSyndicatesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchSyndicatesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTutorialDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tutorials
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetTutorialDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTutorialDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchTutorialsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tutorials
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchTutorialsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchTutorialsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUpgradeTypesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpgradeTypes
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetUpgradeTypesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUpgradeTypesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUpgradeTypesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpgradeTypes
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchUpgradeTypesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUpgradeTypesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWarframesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Warframes
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetWarframesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWarframesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchWarframesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Warframes
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchWarframesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchWarframesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchWarframeDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Warframe
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchWarframeDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchWarframeDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWeaponsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Weapons
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetWeaponsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWeaponsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchWeaponsDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Weapons
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchWeaponsDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchWeaponsDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchWeaponDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Weapon
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchWeaponDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchWeaponDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorldstateByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ws
	JSON400      *GetWorldstateByPlatform400Response
	JSON404      *GetWorldstateByPlatform404Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetWorldstateByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorldstateByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlertsByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Alerts
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetAlertsByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlertsByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArbitrationByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Arbitration
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetArbitrationByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArbitrationByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArchonHuntByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArchonHunt
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetArchonHuntByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArchonHuntByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCambionByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CambionCycle
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetCambionByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCambionByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCetusByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CetusCycle
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetCetusByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCetusByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConclaveChallengesByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConclaveChallenges
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetConclaveChallengesByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConclaveChallengesByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConstructionByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Construction
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetConstructionByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConstructionByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDealsByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DailyDeals
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetDealsByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDealsByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDarkSectorsByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DarkSectors
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetDarkSectorsByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDarkSectorsByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEarthByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EarthCycle
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetEarthByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEarthByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventsByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Events
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetEventsByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventsByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFissuresByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Fissures
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetFissuresByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFissuresByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSalesByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FlashSales
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetSalesByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSalesByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalEffectsByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalUpgrades
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetGlobalEffectsByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalEffectsByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvasionsByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Invasions
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetInvasionsByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvasionsByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKuvaByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Arbitration
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetKuvaByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKuvaByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNewsByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *News
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetNewsByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNewsByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNightwaveByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Nightwave
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetNightwaveByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNightwaveByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAcolytesByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersistentEnemies
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetAcolytesByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAcolytesByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRivensByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RivenType
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetRivensByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRivensByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRivensByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RivenType
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r SearchRivensByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRivensByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutpostsByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOutpostsByPlatform200Response
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetOutpostsByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutpostsByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSimarisByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Simaris
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetSimarisByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSimarisByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSortieByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sortie
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetSortieByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSortieByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSteelPathByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SteelPath
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetSteelPathByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSteelPathByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSyndicatesByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyndicateMissions
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetSyndicatesByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSyndicatesByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTimestampByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Timestamp
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetTimestampByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTimestampByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVallisByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VallisCycle
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetVallisByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVallisByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVarziaByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoidTrader
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetVarziaByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVarziaByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBaroByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoidTrader
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetBaroByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBaroByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVoidTradersByPlatformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]VoidTrader
	JSON400      *GetWorldstateByPlatform400Response
	JSON500      *GetWorldstateByPlatform400Response
}

// Status returns HTTPResponse.Status
func (r GetVoidTradersByPlatformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVoidTradersByPlatformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetArcanesDataWithResponse request returning *GetArcanesDataResponse
func (c *ClientWithResponses) GetArcanesDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetArcanesDataResponse, error) {
	rsp, err := c.GetArcanesData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArcanesDataResponse(rsp)
}

// SearchArcanesDataWithResponse request returning *SearchArcanesDataResponse
func (c *ClientWithResponses) SearchArcanesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchArcanesDataResponse, error) {
	rsp, err := c.SearchArcanesData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchArcanesDataResponse(rsp)
}

// GetConclaveDataWithResponse request returning *GetConclaveDataResponse
func (c *ClientWithResponses) GetConclaveDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConclaveDataResponse, error) {
	rsp, err := c.GetConclaveData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConclaveDataResponse(rsp)
}

// SearchConclavesDataWithResponse request returning *SearchConclavesDataResponse
func (c *ClientWithResponses) SearchConclavesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchConclavesDataResponse, error) {
	rsp, err := c.SearchConclavesData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchConclavesDataResponse(rsp)
}

// SearchDropsDataWithResponse request returning *SearchDropsDataResponse
func (c *ClientWithResponses) SearchDropsDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchDropsDataResponse, error) {
	rsp, err := c.SearchDropsData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDropsDataResponse(rsp)
}

// GetEventsDataWithResponse request returning *GetEventsDataResponse
func (c *ClientWithResponses) GetEventsDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEventsDataResponse, error) {
	rsp, err := c.GetEventsData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventsDataResponse(rsp)
}

// SearchEventsDataWithResponse request returning *SearchEventsDataResponse
func (c *ClientWithResponses) SearchEventsDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchEventsDataResponse, error) {
	rsp, err := c.SearchEventsData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchEventsDataResponse(rsp)
}

// GetFactionsDataWithResponse request returning *GetFactionsDataResponse
func (c *ClientWithResponses) GetFactionsDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFactionsDataResponse, error) {
	rsp, err := c.GetFactionsData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFactionsDataResponse(rsp)
}

// SearchFactionsDataWithResponse request returning *SearchFactionsDataResponse
func (c *ClientWithResponses) SearchFactionsDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchFactionsDataResponse, error) {
	rsp, err := c.SearchFactionsData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchFactionsDataResponse(rsp)
}

// GetFissuresDataWithResponse request returning *GetFissuresDataResponse
func (c *ClientWithResponses) GetFissuresDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFissuresDataResponse, error) {
	rsp, err := c.GetFissuresData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFissuresDataResponse(rsp)
}

// SearchFissuresDataWithResponse request returning *SearchFissuresDataResponse
func (c *ClientWithResponses) SearchFissuresDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchFissuresDataResponse, error) {
	rsp, err := c.SearchFissuresData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchFissuresDataResponse(rsp)
}

// GetItemsDataWithResponse request returning *GetItemsDataResponse
func (c *ClientWithResponses) GetItemsDataWithResponse(ctx context.Context, params *GetItemsDataParams, reqEditors ...RequestEditorFn) (*GetItemsDataResponse, error) {
	rsp, err := c.GetItemsData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetItemsDataResponse(rsp)
}

// SearchItemsDataWithResponse request returning *SearchItemsDataResponse
func (c *ClientWithResponses) SearchItemsDataWithResponse(ctx context.Context, query string, params *SearchItemsDataParams, reqEditors ...RequestEditorFn) (*SearchItemsDataResponse, error) {
	rsp, err := c.SearchItemsData(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchItemsDataResponse(rsp)
}

// SearchItemDataWithResponse request returning *SearchItemDataResponse
func (c *ClientWithResponses) SearchItemDataWithResponse(ctx context.Context, query string, params *SearchItemDataParams, reqEditors ...RequestEditorFn) (*SearchItemDataResponse, error) {
	rsp, err := c.SearchItemData(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchItemDataResponse(rsp)
}

// GetLanguageDataWithResponse request returning *GetLanguageDataResponse
func (c *ClientWithResponses) GetLanguageDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLanguageDataResponse, error) {
	rsp, err := c.GetLanguageData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLanguageDataResponse(rsp)
}

// SearchLanguagesDataWithResponse request returning *SearchLanguagesDataResponse
func (c *ClientWithResponses) SearchLanguagesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchLanguagesDataResponse, error) {
	rsp, err := c.SearchLanguagesData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchLanguagesDataResponse(rsp)
}

// GetLocalesWithResponse request returning *GetLocalesResponse
func (c *ClientWithResponses) GetLocalesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLocalesResponse, error) {
	rsp, err := c.GetLocales(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocalesResponse(rsp)
}

// GetMissionDataWithResponse request returning *GetMissionDataResponse
func (c *ClientWithResponses) GetMissionDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMissionDataResponse, error) {
	rsp, err := c.GetMissionData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMissionDataResponse(rsp)
}

// SearchMissionTypesDataWithResponse request returning *SearchMissionTypesDataResponse
func (c *ClientWithResponses) SearchMissionTypesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchMissionTypesDataResponse, error) {
	rsp, err := c.SearchMissionTypesData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchMissionTypesDataResponse(rsp)
}

// GetModsDataWithResponse request returning *GetModsDataResponse
func (c *ClientWithResponses) GetModsDataWithResponse(ctx context.Context, params *GetModsDataParams, reqEditors ...RequestEditorFn) (*GetModsDataResponse, error) {
	rsp, err := c.GetModsData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModsDataResponse(rsp)
}

// SearchModsDataWithResponse request returning *SearchModsDataResponse
func (c *ClientWithResponses) SearchModsDataWithResponse(ctx context.Context, query string, params *SearchModsDataParams, reqEditors ...RequestEditorFn) (*SearchModsDataResponse, error) {
	rsp, err := c.SearchModsData(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchModsDataResponse(rsp)
}

// SearchModDataWithResponse request returning *SearchModDataResponse
func (c *ClientWithResponses) SearchModDataWithResponse(ctx context.Context, query string, params *SearchModDataParams, reqEditors ...RequestEditorFn) (*SearchModDataResponse, error) {
	rsp, err := c.SearchModData(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchModDataResponse(rsp)
}

// GetOperationsDataWithResponse request returning *GetOperationsDataResponse
func (c *ClientWithResponses) GetOperationsDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOperationsDataResponse, error) {
	rsp, err := c.GetOperationsData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOperationsDataResponse(rsp)
}

// SearchOperationsDataWithResponse request returning *SearchOperationsDataResponse
func (c *ClientWithResponses) SearchOperationsDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchOperationsDataResponse, error) {
	rsp, err := c.SearchOperationsData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchOperationsDataResponse(rsp)
}

// GetAcolyteDataWithResponse request returning *GetAcolyteDataResponse
func (c *ClientWithResponses) GetAcolyteDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAcolyteDataResponse, error) {
	rsp, err := c.GetAcolyteData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAcolyteDataResponse(rsp)
}

// SearchAcolytesDataWithResponse request returning *SearchAcolytesDataResponse
func (c *ClientWithResponses) SearchAcolytesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchAcolytesDataResponse, error) {
	rsp, err := c.SearchAcolytesData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchAcolytesDataResponse(rsp)
}

// GetNodeDataWithResponse request returning *GetNodeDataResponse
func (c *ClientWithResponses) GetNodeDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNodeDataResponse, error) {
	rsp, err := c.GetNodeData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNodeDataResponse(rsp)
}

// SearchNodesDataWithResponse request returning *SearchNodesDataResponse
func (c *ClientWithResponses) SearchNodesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchNodesDataResponse, error) {
	rsp, err := c.SearchNodesData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchNodesDataResponse(rsp)
}

// GetSortieDataWithResponse request returning *GetSortieDataResponse
func (c *ClientWithResponses) GetSortieDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSortieDataResponse, error) {
	rsp, err := c.GetSortieData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSortieDataResponse(rsp)
}

// SearchSortiesDataWithResponse request returning *SearchSortiesDataResponse
func (c *ClientWithResponses) SearchSortiesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchSortiesDataResponse, error) {
	rsp, err := c.SearchSortiesData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchSortiesDataResponse(rsp)
}

// GetSyndicateDataWithResponse request returning *GetSyndicateDataResponse
func (c *ClientWithResponses) GetSyndicateDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSyndicateDataResponse, error) {
	rsp, err := c.GetSyndicateData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyndicateDataResponse(rsp)
}

// SearchSyndicatesDataWithResponse request returning *SearchSyndicatesDataResponse
func (c *ClientWithResponses) SearchSyndicatesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchSyndicatesDataResponse, error) {
	rsp, err := c.SearchSyndicatesData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchSyndicatesDataResponse(rsp)
}

// GetTutorialDataWithResponse request returning *GetTutorialDataResponse
func (c *ClientWithResponses) GetTutorialDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTutorialDataResponse, error) {
	rsp, err := c.GetTutorialData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTutorialDataResponse(rsp)
}

// SearchTutorialsDataWithResponse request returning *SearchTutorialsDataResponse
func (c *ClientWithResponses) SearchTutorialsDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchTutorialsDataResponse, error) {
	rsp, err := c.SearchTutorialsData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchTutorialsDataResponse(rsp)
}

// GetUpgradeTypesDataWithResponse request returning *GetUpgradeTypesDataResponse
func (c *ClientWithResponses) GetUpgradeTypesDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUpgradeTypesDataResponse, error) {
	rsp, err := c.GetUpgradeTypesData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUpgradeTypesDataResponse(rsp)
}

// SearchUpgradeTypesDataWithResponse request returning *SearchUpgradeTypesDataResponse
func (c *ClientWithResponses) SearchUpgradeTypesDataWithResponse(ctx context.Context, query string, reqEditors ...RequestEditorFn) (*SearchUpgradeTypesDataResponse, error) {
	rsp, err := c.SearchUpgradeTypesData(ctx, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUpgradeTypesDataResponse(rsp)
}

// GetWarframesDataWithResponse request returning *GetWarframesDataResponse
func (c *ClientWithResponses) GetWarframesDataWithResponse(ctx context.Context, params *GetWarframesDataParams, reqEditors ...RequestEditorFn) (*GetWarframesDataResponse, error) {
	rsp, err := c.GetWarframesData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWarframesDataResponse(rsp)
}

// SearchWarframesDataWithResponse request returning *SearchWarframesDataResponse
func (c *ClientWithResponses) SearchWarframesDataWithResponse(ctx context.Context, query string, params *SearchWarframesDataParams, reqEditors ...RequestEditorFn) (*SearchWarframesDataResponse, error) {
	rsp, err := c.SearchWarframesData(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchWarframesDataResponse(rsp)
}

// SearchWarframeDataWithResponse request returning *SearchWarframeDataResponse
func (c *ClientWithResponses) SearchWarframeDataWithResponse(ctx context.Context, query string, params *SearchWarframeDataParams, reqEditors ...RequestEditorFn) (*SearchWarframeDataResponse, error) {
	rsp, err := c.SearchWarframeData(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchWarframeDataResponse(rsp)
}

// GetWeaponsDataWithResponse request returning *GetWeaponsDataResponse
func (c *ClientWithResponses) GetWeaponsDataWithResponse(ctx context.Context, params *GetWeaponsDataParams, reqEditors ...RequestEditorFn) (*GetWeaponsDataResponse, error) {
	rsp, err := c.GetWeaponsData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWeaponsDataResponse(rsp)
}

// SearchWeaponsDataWithResponse request returning *SearchWeaponsDataResponse
func (c *ClientWithResponses) SearchWeaponsDataWithResponse(ctx context.Context, query string, params *SearchWeaponsDataParams, reqEditors ...RequestEditorFn) (*SearchWeaponsDataResponse, error) {
	rsp, err := c.SearchWeaponsData(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchWeaponsDataResponse(rsp)
}

// SearchWeaponDataWithResponse request returning *SearchWeaponDataResponse
func (c *ClientWithResponses) SearchWeaponDataWithResponse(ctx context.Context, query string, params *SearchWeaponDataParams, reqEditors ...RequestEditorFn) (*SearchWeaponDataResponse, error) {
	rsp, err := c.SearchWeaponData(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchWeaponDataResponse(rsp)
}

// GetWorldstateByPlatformWithResponse request returning *GetWorldstateByPlatformResponse
func (c *ClientWithResponses) GetWorldstateByPlatformWithResponse(ctx context.Context, platform Platform, params *GetWorldstateByPlatformParams, reqEditors ...RequestEditorFn) (*GetWorldstateByPlatformResponse, error) {
	rsp, err := c.GetWorldstateByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorldstateByPlatformResponse(rsp)
}

// GetAlertsByPlatformWithResponse request returning *GetAlertsByPlatformResponse
func (c *ClientWithResponses) GetAlertsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetAlertsByPlatformParams, reqEditors ...RequestEditorFn) (*GetAlertsByPlatformResponse, error) {
	rsp, err := c.GetAlertsByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlertsByPlatformResponse(rsp)
}

// GetArbitrationByPlatformWithResponse request returning *GetArbitrationByPlatformResponse
func (c *ClientWithResponses) GetArbitrationByPlatformWithResponse(ctx context.Context, platform Platform, params *GetArbitrationByPlatformParams, reqEditors ...RequestEditorFn) (*GetArbitrationByPlatformResponse, error) {
	rsp, err := c.GetArbitrationByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArbitrationByPlatformResponse(rsp)
}

// GetArchonHuntByPlatformWithResponse request returning *GetArchonHuntByPlatformResponse
func (c *ClientWithResponses) GetArchonHuntByPlatformWithResponse(ctx context.Context, platform Platform, params *GetArchonHuntByPlatformParams, reqEditors ...RequestEditorFn) (*GetArchonHuntByPlatformResponse, error) {
	rsp, err := c.GetArchonHuntByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArchonHuntByPlatformResponse(rsp)
}

// GetCambionByPlatformWithResponse request returning *GetCambionByPlatformResponse
func (c *ClientWithResponses) GetCambionByPlatformWithResponse(ctx context.Context, platform Platform, params *GetCambionByPlatformParams, reqEditors ...RequestEditorFn) (*GetCambionByPlatformResponse, error) {
	rsp, err := c.GetCambionByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCambionByPlatformResponse(rsp)
}

// GetCetusByPlatformWithResponse request returning *GetCetusByPlatformResponse
func (c *ClientWithResponses) GetCetusByPlatformWithResponse(ctx context.Context, platform Platform, params *GetCetusByPlatformParams, reqEditors ...RequestEditorFn) (*GetCetusByPlatformResponse, error) {
	rsp, err := c.GetCetusByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCetusByPlatformResponse(rsp)
}

// GetConclaveChallengesByPlatformWithResponse request returning *GetConclaveChallengesByPlatformResponse
func (c *ClientWithResponses) GetConclaveChallengesByPlatformWithResponse(ctx context.Context, platform Platform, params *GetConclaveChallengesByPlatformParams, reqEditors ...RequestEditorFn) (*GetConclaveChallengesByPlatformResponse, error) {
	rsp, err := c.GetConclaveChallengesByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConclaveChallengesByPlatformResponse(rsp)
}

// GetConstructionByPlatformWithResponse request returning *GetConstructionByPlatformResponse
func (c *ClientWithResponses) GetConstructionByPlatformWithResponse(ctx context.Context, platform Platform, params *GetConstructionByPlatformParams, reqEditors ...RequestEditorFn) (*GetConstructionByPlatformResponse, error) {
	rsp, err := c.GetConstructionByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConstructionByPlatformResponse(rsp)
}

// GetDealsByPlatformWithResponse request returning *GetDealsByPlatformResponse
func (c *ClientWithResponses) GetDealsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetDealsByPlatformParams, reqEditors ...RequestEditorFn) (*GetDealsByPlatformResponse, error) {
	rsp, err := c.GetDealsByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDealsByPlatformResponse(rsp)
}

// GetDarkSectorsByPlatformWithResponse request returning *GetDarkSectorsByPlatformResponse
func (c *ClientWithResponses) GetDarkSectorsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetDarkSectorsByPlatformParams, reqEditors ...RequestEditorFn) (*GetDarkSectorsByPlatformResponse, error) {
	rsp, err := c.GetDarkSectorsByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDarkSectorsByPlatformResponse(rsp)
}

// GetEarthByPlatformWithResponse request returning *GetEarthByPlatformResponse
func (c *ClientWithResponses) GetEarthByPlatformWithResponse(ctx context.Context, platform Platform, params *GetEarthByPlatformParams, reqEditors ...RequestEditorFn) (*GetEarthByPlatformResponse, error) {
	rsp, err := c.GetEarthByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEarthByPlatformResponse(rsp)
}

// GetEventsByPlatformWithResponse request returning *GetEventsByPlatformResponse
func (c *ClientWithResponses) GetEventsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetEventsByPlatformParams, reqEditors ...RequestEditorFn) (*GetEventsByPlatformResponse, error) {
	rsp, err := c.GetEventsByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventsByPlatformResponse(rsp)
}

// GetFissuresByPlatformWithResponse request returning *GetFissuresByPlatformResponse
func (c *ClientWithResponses) GetFissuresByPlatformWithResponse(ctx context.Context, platform Platform, params *GetFissuresByPlatformParams, reqEditors ...RequestEditorFn) (*GetFissuresByPlatformResponse, error) {
	rsp, err := c.GetFissuresByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFissuresByPlatformResponse(rsp)
}

// GetSalesByPlatformWithResponse request returning *GetSalesByPlatformResponse
func (c *ClientWithResponses) GetSalesByPlatformWithResponse(ctx context.Context, platform Platform, params *GetSalesByPlatformParams, reqEditors ...RequestEditorFn) (*GetSalesByPlatformResponse, error) {
	rsp, err := c.GetSalesByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSalesByPlatformResponse(rsp)
}

// GetGlobalEffectsByPlatformWithResponse request returning *GetGlobalEffectsByPlatformResponse
func (c *ClientWithResponses) GetGlobalEffectsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetGlobalEffectsByPlatformParams, reqEditors ...RequestEditorFn) (*GetGlobalEffectsByPlatformResponse, error) {
	rsp, err := c.GetGlobalEffectsByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalEffectsByPlatformResponse(rsp)
}

// GetInvasionsByPlatformWithResponse request returning *GetInvasionsByPlatformResponse
func (c *ClientWithResponses) GetInvasionsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetInvasionsByPlatformParams, reqEditors ...RequestEditorFn) (*GetInvasionsByPlatformResponse, error) {
	rsp, err := c.GetInvasionsByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvasionsByPlatformResponse(rsp)
}

// GetKuvaByPlatformWithResponse request returning *GetKuvaByPlatformResponse
func (c *ClientWithResponses) GetKuvaByPlatformWithResponse(ctx context.Context, platform Platform, params *GetKuvaByPlatformParams, reqEditors ...RequestEditorFn) (*GetKuvaByPlatformResponse, error) {
	rsp, err := c.GetKuvaByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKuvaByPlatformResponse(rsp)
}

// GetNewsByPlatformWithResponse request returning *GetNewsByPlatformResponse
func (c *ClientWithResponses) GetNewsByPlatformWithResponse(ctx context.Context, platform Platform, reqEditors ...RequestEditorFn) (*GetNewsByPlatformResponse, error) {
	rsp, err := c.GetNewsByPlatform(ctx, platform, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNewsByPlatformResponse(rsp)
}

// GetNightwaveByPlatformWithResponse request returning *GetNightwaveByPlatformResponse
func (c *ClientWithResponses) GetNightwaveByPlatformWithResponse(ctx context.Context, platform Platform, params *GetNightwaveByPlatformParams, reqEditors ...RequestEditorFn) (*GetNightwaveByPlatformResponse, error) {
	rsp, err := c.GetNightwaveByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNightwaveByPlatformResponse(rsp)
}

// GetAcolytesByPlatformWithResponse request returning *GetAcolytesByPlatformResponse
func (c *ClientWithResponses) GetAcolytesByPlatformWithResponse(ctx context.Context, platform Platform, params *GetAcolytesByPlatformParams, reqEditors ...RequestEditorFn) (*GetAcolytesByPlatformResponse, error) {
	rsp, err := c.GetAcolytesByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAcolytesByPlatformResponse(rsp)
}

// GetRivensByPlatformWithResponse request returning *GetRivensByPlatformResponse
func (c *ClientWithResponses) GetRivensByPlatformWithResponse(ctx context.Context, platform Platform, params *GetRivensByPlatformParams, reqEditors ...RequestEditorFn) (*GetRivensByPlatformResponse, error) {
	rsp, err := c.GetRivensByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRivensByPlatformResponse(rsp)
}

// SearchRivensByPlatformWithResponse request returning *SearchRivensByPlatformResponse
func (c *ClientWithResponses) SearchRivensByPlatformWithResponse(ctx context.Context, platform Platform, query string, reqEditors ...RequestEditorFn) (*SearchRivensByPlatformResponse, error) {
	rsp, err := c.SearchRivensByPlatform(ctx, platform, query, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRivensByPlatformResponse(rsp)
}

// GetOutpostsByPlatformWithResponse request returning *GetOutpostsByPlatformResponse
func (c *ClientWithResponses) GetOutpostsByPlatformWithResponse(ctx context.Context, platform Platform, params *GetOutpostsByPlatformParams, reqEditors ...RequestEditorFn) (*GetOutpostsByPlatformResponse, error) {
	rsp, err := c.GetOutpostsByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutpostsByPlatformResponse(rsp)
}

// GetSimarisByPlatformWithResponse request returning *GetSimarisByPlatformResponse
func (c *ClientWithResponses) GetSimarisByPlatformWithResponse(ctx context.Context, platform Platform, params *GetSimarisByPlatformParams, reqEditors ...RequestEditorFn) (*GetSimarisByPlatformResponse, error) {
	rsp, err := c.GetSimarisByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSimarisByPlatformResponse(rsp)
}

// GetSortieByPlatformWithResponse request returning *GetSortieByPlatformResponse
func (c *ClientWithResponses) GetSortieByPlatformWithResponse(ctx context.Context, platform Platform, params *GetSortieByPlatformParams, reqEditors ...RequestEditorFn) (*GetSortieByPlatformResponse, error) {
	rsp, err := c.GetSortieByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSortieByPlatformResponse(rsp)
}

// GetSteelPathByPlatformWithResponse request returning *GetSteelPathByPlatformResponse
func (c *ClientWithResponses) GetSteelPathByPlatformWithResponse(ctx context.Context, platform Platform, params *GetSteelPathByPlatformParams, reqEditors ...RequestEditorFn) (*GetSteelPathByPlatformResponse, error) {
	rsp, err := c.GetSteelPathByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSteelPathByPlatformResponse(rsp)
}

// GetSyndicatesByPlatformWithResponse request returning *GetSyndicatesByPlatformResponse
func (c *ClientWithResponses) GetSyndicatesByPlatformWithResponse(ctx context.Context, platform Platform, params *GetSyndicatesByPlatformParams, reqEditors ...RequestEditorFn) (*GetSyndicatesByPlatformResponse, error) {
	rsp, err := c.GetSyndicatesByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSyndicatesByPlatformResponse(rsp)
}

// GetTimestampByPlatformWithResponse request returning *GetTimestampByPlatformResponse
func (c *ClientWithResponses) GetTimestampByPlatformWithResponse(ctx context.Context, platform Platform, params *GetTimestampByPlatformParams, reqEditors ...RequestEditorFn) (*GetTimestampByPlatformResponse, error) {
	rsp, err := c.GetTimestampByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTimestampByPlatformResponse(rsp)
}

// GetVallisByPlatformWithResponse request returning *GetVallisByPlatformResponse
func (c *ClientWithResponses) GetVallisByPlatformWithResponse(ctx context.Context, platform Platform, params *GetVallisByPlatformParams, reqEditors ...RequestEditorFn) (*GetVallisByPlatformResponse, error) {
	rsp, err := c.GetVallisByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVallisByPlatformResponse(rsp)
}

// GetVarziaByPlatformWithResponse request returning *GetVarziaByPlatformResponse
func (c *ClientWithResponses) GetVarziaByPlatformWithResponse(ctx context.Context, platform Platform, params *GetVarziaByPlatformParams, reqEditors ...RequestEditorFn) (*GetVarziaByPlatformResponse, error) {
	rsp, err := c.GetVarziaByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVarziaByPlatformResponse(rsp)
}

// GetBaroByPlatformWithResponse request returning *GetBaroByPlatformResponse
func (c *ClientWithResponses) GetBaroByPlatformWithResponse(ctx context.Context, platform Platform, params *GetBaroByPlatformParams, reqEditors ...RequestEditorFn) (*GetBaroByPlatformResponse, error) {
	rsp, err := c.GetBaroByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBaroByPlatformResponse(rsp)
}

// GetVoidTradersByPlatformWithResponse request returning *GetVoidTradersByPlatformResponse
func (c *ClientWithResponses) GetVoidTradersByPlatformWithResponse(ctx context.Context, platform Platform, params *GetVoidTradersByPlatformParams, reqEditors ...RequestEditorFn) (*GetVoidTradersByPlatformResponse, error) {
	rsp, err := c.GetVoidTradersByPlatform(ctx, platform, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVoidTradersByPlatformResponse(rsp)
}

// ParseGetArcanesDataResponse parses an HTTP response from a GetArcanesDataWithResponse call
func ParseGetArcanesDataResponse(rsp *http.Response) (*GetArcanesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArcanesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Arcane
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchArcanesDataResponse parses an HTTP response from a SearchArcanesDataWithResponse call
func ParseSearchArcanesDataResponse(rsp *http.Response) (*SearchArcanesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchArcanesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Arcane
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConclaveDataResponse parses an HTTP response from a GetConclaveDataWithResponse call
func ParseGetConclaveDataResponse(rsp *http.Response) (*GetConclaveDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConclaveDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Conclave
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchConclavesDataResponse parses an HTTP response from a SearchConclavesDataWithResponse call
func ParseSearchConclavesDataResponse(rsp *http.Response) (*SearchConclavesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchConclavesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Conclave
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchDropsDataResponse parses an HTTP response from a SearchDropsDataWithResponse call
func ParseSearchDropsDataResponse(rsp *http.Response) (*SearchDropsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDropsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Drops
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEventsDataResponse parses an HTTP response from a GetEventsDataWithResponse call
func ParseGetEventsDataResponse(rsp *http.Response) (*GetEventsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchEventsDataResponse parses an HTTP response from a SearchEventsDataWithResponse call
func ParseSearchEventsDataResponse(rsp *http.Response) (*SearchEventsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchEventsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFactionsDataResponse parses an HTTP response from a GetFactionsDataWithResponse call
func ParseGetFactionsDataResponse(rsp *http.Response) (*GetFactionsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFactionsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Factions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchFactionsDataResponse parses an HTTP response from a SearchFactionsDataWithResponse call
func ParseSearchFactionsDataResponse(rsp *http.Response) (*SearchFactionsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchFactionsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Factions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFissuresDataResponse parses an HTTP response from a GetFissuresDataWithResponse call
func ParseGetFissuresDataResponse(rsp *http.Response) (*GetFissuresDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFissuresDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FissureModifiers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchFissuresDataResponse parses an HTTP response from a SearchFissuresDataWithResponse call
func ParseSearchFissuresDataResponse(rsp *http.Response) (*SearchFissuresDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchFissuresDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FissureModifiers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetItemsDataResponse parses an HTTP response from a GetItemsDataWithResponse call
func ParseGetItemsDataResponse(rsp *http.Response) (*GetItemsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetItemsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Items
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchItemsDataResponse parses an HTTP response from a SearchItemsDataWithResponse call
func ParseSearchItemsDataResponse(rsp *http.Response) (*SearchItemsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchItemsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Items
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchItemDataResponse parses an HTTP response from a SearchItemDataWithResponse call
func ParseSearchItemDataResponse(rsp *http.Response) (*SearchItemDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchItemDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLanguageDataResponse parses an HTTP response from a GetLanguageDataWithResponse call
func ParseGetLanguageDataResponse(rsp *http.Response) (*GetLanguageDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLanguageDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Languages
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchLanguagesDataResponse parses an HTTP response from a SearchLanguagesDataWithResponse call
func ParseSearchLanguagesDataResponse(rsp *http.Response) (*SearchLanguagesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchLanguagesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Languages
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocalesResponse parses an HTTP response from a GetLocalesWithResponse call
func ParseGetLocalesResponse(rsp *http.Response) (*GetLocalesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocalesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Language
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMissionDataResponse parses an HTTP response from a GetMissionDataWithResponse call
func ParseGetMissionDataResponse(rsp *http.Response) (*GetMissionDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMissionDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MissionTypes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchMissionTypesDataResponse parses an HTTP response from a SearchMissionTypesDataWithResponse call
func ParseSearchMissionTypesDataResponse(rsp *http.Response) (*SearchMissionTypesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchMissionTypesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MissionTypes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetModsDataResponse parses an HTTP response from a GetModsDataWithResponse call
func ParseGetModsDataResponse(rsp *http.Response) (*GetModsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Mod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchModsDataResponse parses an HTTP response from a SearchModsDataWithResponse call
func ParseSearchModsDataResponse(rsp *http.Response) (*SearchModsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchModsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Mod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchModDataResponse parses an HTTP response from a SearchModDataWithResponse call
func ParseSearchModDataResponse(rsp *http.Response) (*SearchModDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchModDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Mod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOperationsDataResponse parses an HTTP response from a GetOperationsDataWithResponse call
func ParseGetOperationsDataResponse(rsp *http.Response) (*GetOperationsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOperationsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperationTypes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchOperationsDataResponse parses an HTTP response from a SearchOperationsDataWithResponse call
func ParseSearchOperationsDataResponse(rsp *http.Response) (*SearchOperationsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchOperationsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperationTypes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAcolyteDataResponse parses an HTTP response from a GetAcolyteDataWithResponse call
func ParseGetAcolyteDataResponse(rsp *http.Response) (*GetAcolyteDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAcolyteDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AcolyteI18n
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchAcolytesDataResponse parses an HTTP response from a SearchAcolytesDataWithResponse call
func ParseSearchAcolytesDataResponse(rsp *http.Response) (*SearchAcolytesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchAcolytesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SearchAcolytesData200ResponseInner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNodeDataResponse parses an HTTP response from a GetNodeDataWithResponse call
func ParseGetNodeDataResponse(rsp *http.Response) (*GetNodeDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNodeDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SolNode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchNodesDataResponse parses an HTTP response from a SearchNodesDataWithResponse call
func ParseSearchNodesDataResponse(rsp *http.Response) (*SearchNodesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchNodesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SolNodeSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSortieDataResponse parses an HTTP response from a GetSortieDataWithResponse call
func ParseGetSortieDataResponse(rsp *http.Response) (*GetSortieDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSortieDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SortieData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchSortiesDataResponse parses an HTTP response from a SearchSortiesDataWithResponse call
func ParseSearchSortiesDataResponse(rsp *http.Response) (*SearchSortiesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchSortiesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SortieData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyndicateDataResponse parses an HTTP response from a GetSyndicateDataWithResponse call
func ParseGetSyndicateDataResponse(rsp *http.Response) (*GetSyndicateDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyndicateDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Syndicates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchSyndicatesDataResponse parses an HTTP response from a SearchSyndicatesDataWithResponse call
func ParseSearchSyndicatesDataResponse(rsp *http.Response) (*SearchSyndicatesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchSyndicatesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Syndicates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTutorialDataResponse parses an HTTP response from a GetTutorialDataWithResponse call
func ParseGetTutorialDataResponse(rsp *http.Response) (*GetTutorialDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTutorialDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tutorials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchTutorialsDataResponse parses an HTTP response from a SearchTutorialsDataWithResponse call
func ParseSearchTutorialsDataResponse(rsp *http.Response) (*SearchTutorialsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchTutorialsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tutorials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUpgradeTypesDataResponse parses an HTTP response from a GetUpgradeTypesDataWithResponse call
func ParseGetUpgradeTypesDataResponse(rsp *http.Response) (*GetUpgradeTypesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUpgradeTypesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpgradeTypes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchUpgradeTypesDataResponse parses an HTTP response from a SearchUpgradeTypesDataWithResponse call
func ParseSearchUpgradeTypesDataResponse(rsp *http.Response) (*SearchUpgradeTypesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUpgradeTypesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpgradeTypes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWarframesDataResponse parses an HTTP response from a GetWarframesDataWithResponse call
func ParseGetWarframesDataResponse(rsp *http.Response) (*GetWarframesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWarframesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Warframes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchWarframesDataResponse parses an HTTP response from a SearchWarframesDataWithResponse call
func ParseSearchWarframesDataResponse(rsp *http.Response) (*SearchWarframesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchWarframesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Warframes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchWarframeDataResponse parses an HTTP response from a SearchWarframeDataWithResponse call
func ParseSearchWarframeDataResponse(rsp *http.Response) (*SearchWarframeDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchWarframeDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Warframe
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWeaponsDataResponse parses an HTTP response from a GetWeaponsDataWithResponse call
func ParseGetWeaponsDataResponse(rsp *http.Response) (*GetWeaponsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWeaponsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Weapons
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchWeaponsDataResponse parses an HTTP response from a SearchWeaponsDataWithResponse call
func ParseSearchWeaponsDataResponse(rsp *http.Response) (*SearchWeaponsDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchWeaponsDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Weapons
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchWeaponDataResponse parses an HTTP response from a SearchWeaponDataWithResponse call
func ParseSearchWeaponDataResponse(rsp *http.Response) (*SearchWeaponDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchWeaponDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Weapon
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWorldstateByPlatformResponse parses an HTTP response from a GetWorldstateByPlatformWithResponse call
func ParseGetWorldstateByPlatformResponse(rsp *http.Response) (*GetWorldstateByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorldstateByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ws
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GetWorldstateByPlatform404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAlertsByPlatformResponse parses an HTTP response from a GetAlertsByPlatformWithResponse call
func ParseGetAlertsByPlatformResponse(rsp *http.Response) (*GetAlertsByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlertsByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Alerts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetArbitrationByPlatformResponse parses an HTTP response from a GetArbitrationByPlatformWithResponse call
func ParseGetArbitrationByPlatformResponse(rsp *http.Response) (*GetArbitrationByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArbitrationByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Arbitration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetArchonHuntByPlatformResponse parses an HTTP response from a GetArchonHuntByPlatformWithResponse call
func ParseGetArchonHuntByPlatformResponse(rsp *http.Response) (*GetArchonHuntByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArchonHuntByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArchonHunt
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCambionByPlatformResponse parses an HTTP response from a GetCambionByPlatformWithResponse call
func ParseGetCambionByPlatformResponse(rsp *http.Response) (*GetCambionByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCambionByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CambionCycle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCetusByPlatformResponse parses an HTTP response from a GetCetusByPlatformWithResponse call
func ParseGetCetusByPlatformResponse(rsp *http.Response) (*GetCetusByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCetusByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CetusCycle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConclaveChallengesByPlatformResponse parses an HTTP response from a GetConclaveChallengesByPlatformWithResponse call
func ParseGetConclaveChallengesByPlatformResponse(rsp *http.Response) (*GetConclaveChallengesByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConclaveChallengesByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConclaveChallenges
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConstructionByPlatformResponse parses an HTTP response from a GetConstructionByPlatformWithResponse call
func ParseGetConstructionByPlatformResponse(rsp *http.Response) (*GetConstructionByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConstructionByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Construction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDealsByPlatformResponse parses an HTTP response from a GetDealsByPlatformWithResponse call
func ParseGetDealsByPlatformResponse(rsp *http.Response) (*GetDealsByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDealsByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DailyDeals
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDarkSectorsByPlatformResponse parses an HTTP response from a GetDarkSectorsByPlatformWithResponse call
func ParseGetDarkSectorsByPlatformResponse(rsp *http.Response) (*GetDarkSectorsByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDarkSectorsByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DarkSectors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEarthByPlatformResponse parses an HTTP response from a GetEarthByPlatformWithResponse call
func ParseGetEarthByPlatformResponse(rsp *http.Response) (*GetEarthByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEarthByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EarthCycle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEventsByPlatformResponse parses an HTTP response from a GetEventsByPlatformWithResponse call
func ParseGetEventsByPlatformResponse(rsp *http.Response) (*GetEventsByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventsByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Events
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFissuresByPlatformResponse parses an HTTP response from a GetFissuresByPlatformWithResponse call
func ParseGetFissuresByPlatformResponse(rsp *http.Response) (*GetFissuresByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFissuresByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Fissures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSalesByPlatformResponse parses an HTTP response from a GetSalesByPlatformWithResponse call
func ParseGetSalesByPlatformResponse(rsp *http.Response) (*GetSalesByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSalesByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlashSales
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGlobalEffectsByPlatformResponse parses an HTTP response from a GetGlobalEffectsByPlatformWithResponse call
func ParseGetGlobalEffectsByPlatformResponse(rsp *http.Response) (*GetGlobalEffectsByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalEffectsByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalUpgrades
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInvasionsByPlatformResponse parses an HTTP response from a GetInvasionsByPlatformWithResponse call
func ParseGetInvasionsByPlatformResponse(rsp *http.Response) (*GetInvasionsByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvasionsByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Invasions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKuvaByPlatformResponse parses an HTTP response from a GetKuvaByPlatformWithResponse call
func ParseGetKuvaByPlatformResponse(rsp *http.Response) (*GetKuvaByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKuvaByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Arbitration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNewsByPlatformResponse parses an HTTP response from a GetNewsByPlatformWithResponse call
func ParseGetNewsByPlatformResponse(rsp *http.Response) (*GetNewsByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNewsByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest News
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNightwaveByPlatformResponse parses an HTTP response from a GetNightwaveByPlatformWithResponse call
func ParseGetNightwaveByPlatformResponse(rsp *http.Response) (*GetNightwaveByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNightwaveByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nightwave
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAcolytesByPlatformResponse parses an HTTP response from a GetAcolytesByPlatformWithResponse call
func ParseGetAcolytesByPlatformResponse(rsp *http.Response) (*GetAcolytesByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAcolytesByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersistentEnemies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRivensByPlatformResponse parses an HTTP response from a GetRivensByPlatformWithResponse call
func ParseGetRivensByPlatformResponse(rsp *http.Response) (*GetRivensByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRivensByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RivenType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchRivensByPlatformResponse parses an HTTP response from a SearchRivensByPlatformWithResponse call
func ParseSearchRivensByPlatformResponse(rsp *http.Response) (*SearchRivensByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRivensByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RivenType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOutpostsByPlatformResponse parses an HTTP response from a GetOutpostsByPlatformWithResponse call
func ParseGetOutpostsByPlatformResponse(rsp *http.Response) (*GetOutpostsByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutpostsByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOutpostsByPlatform200Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSimarisByPlatformResponse parses an HTTP response from a GetSimarisByPlatformWithResponse call
func ParseGetSimarisByPlatformResponse(rsp *http.Response) (*GetSimarisByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSimarisByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Simaris
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSortieByPlatformResponse parses an HTTP response from a GetSortieByPlatformWithResponse call
func ParseGetSortieByPlatformResponse(rsp *http.Response) (*GetSortieByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSortieByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sortie
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSteelPathByPlatformResponse parses an HTTP response from a GetSteelPathByPlatformWithResponse call
func ParseGetSteelPathByPlatformResponse(rsp *http.Response) (*GetSteelPathByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSteelPathByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SteelPath
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSyndicatesByPlatformResponse parses an HTTP response from a GetSyndicatesByPlatformWithResponse call
func ParseGetSyndicatesByPlatformResponse(rsp *http.Response) (*GetSyndicatesByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSyndicatesByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyndicateMissions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTimestampByPlatformResponse parses an HTTP response from a GetTimestampByPlatformWithResponse call
func ParseGetTimestampByPlatformResponse(rsp *http.Response) (*GetTimestampByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTimestampByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Timestamp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVallisByPlatformResponse parses an HTTP response from a GetVallisByPlatformWithResponse call
func ParseGetVallisByPlatformResponse(rsp *http.Response) (*GetVallisByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVallisByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VallisCycle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVarziaByPlatformResponse parses an HTTP response from a GetVarziaByPlatformWithResponse call
func ParseGetVarziaByPlatformResponse(rsp *http.Response) (*GetVarziaByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVarziaByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoidTrader
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBaroByPlatformResponse parses an HTTP response from a GetBaroByPlatformWithResponse call
func ParseGetBaroByPlatformResponse(rsp *http.Response) (*GetBaroByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBaroByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoidTrader
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVoidTradersByPlatformResponse parses an HTTP response from a GetVoidTradersByPlatformWithResponse call
func ParseGetVoidTradersByPlatformResponse(rsp *http.Response) (*GetVoidTradersByPlatformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVoidTradersByPlatformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VoidTrader
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest GetWorldstateByPlatform400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
